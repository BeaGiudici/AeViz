[
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Literal",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "griddata",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "interp1d",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "griddata",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "griddata",
        "importPath": "scipy.interpolate",
        "description": "scipy.interpolate",
        "isExtraImport": true,
        "detail": "scipy.interpolate",
        "documentation": {}
    },
    {
        "label": "get_indices_from_parfile",
        "importPath": "AeViz.utils.parfiles",
        "description": "AeViz.utils.parfiles",
        "isExtraImport": true,
        "detail": "AeViz.utils.parfiles",
        "documentation": {}
    },
    {
        "label": "get_indices_from_parfile",
        "importPath": "AeViz.utils.parfiles",
        "description": "AeViz.utils.parfiles",
        "isExtraImport": true,
        "detail": "AeViz.utils.parfiles",
        "documentation": {}
    },
    {
        "label": "get_initial_parameters",
        "importPath": "AeViz.utils.parfiles",
        "description": "AeViz.utils.parfiles",
        "isExtraImport": true,
        "detail": "AeViz.utils.parfiles",
        "documentation": {}
    },
    {
        "label": "Simulation",
        "importPath": "AeViz.simulation.simulation",
        "description": "AeViz.simulation.simulation",
        "isExtraImport": true,
        "detail": "AeViz.simulation.simulation",
        "documentation": {}
    },
    {
        "label": "Simulation",
        "importPath": "AeViz.simulation.simulation",
        "description": "AeViz.simulation.simulation",
        "isExtraImport": true,
        "detail": "AeViz.simulation.simulation",
        "documentation": {}
    },
    {
        "label": "units",
        "importPath": "AeViz.units.units",
        "description": "AeViz.units.units",
        "isExtraImport": true,
        "detail": "AeViz.units.units",
        "documentation": {}
    },
    {
        "label": "units",
        "importPath": "AeViz.units.units",
        "description": "AeViz.units.units",
        "isExtraImport": true,
        "detail": "AeViz.units.units",
        "documentation": {}
    },
    {
        "label": "units",
        "importPath": "AeViz.units.units",
        "description": "AeViz.units.units",
        "isExtraImport": true,
        "detail": "AeViz.units.units",
        "documentation": {}
    },
    {
        "label": "units",
        "importPath": "AeViz.units.units",
        "description": "AeViz.units.units",
        "isExtraImport": true,
        "detail": "AeViz.units.units",
        "documentation": {}
    },
    {
        "label": "units",
        "importPath": "AeViz.units.units",
        "description": "AeViz.units.units",
        "isExtraImport": true,
        "detail": "AeViz.units.units",
        "documentation": {}
    },
    {
        "label": "h5py,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "h5py.",
        "description": "h5py.",
        "detail": "h5py.",
        "documentation": {}
    },
    {
        "label": "cell",
        "importPath": "AeViz.cell.cell",
        "description": "AeViz.cell.cell",
        "isExtraImport": true,
        "detail": "AeViz.cell.cell",
        "documentation": {}
    },
    {
        "label": "cell",
        "importPath": "AeViz.cell.cell",
        "description": "AeViz.cell.cell",
        "isExtraImport": true,
        "detail": "AeViz.cell.cell",
        "documentation": {}
    },
    {
        "label": "ghost",
        "importPath": "AeViz.cell.ghost",
        "description": "AeViz.cell.ghost",
        "isExtraImport": true,
        "detail": "AeViz.cell.ghost",
        "documentation": {}
    },
    {
        "label": "ghost",
        "importPath": "AeViz.cell.ghost",
        "description": "AeViz.cell.ghost",
        "isExtraImport": true,
        "detail": "AeViz.cell.ghost",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "PlotCreation",
        "importPath": "AeViz.plot_utils.plot_creation",
        "description": "AeViz.plot_utils.plot_creation",
        "isExtraImport": true,
        "detail": "AeViz.plot_utils.plot_creation",
        "documentation": {}
    },
    {
        "label": "PlotCreation",
        "importPath": "AeViz.plot_utils.plot_creation",
        "description": "AeViz.plot_utils.plot_creation",
        "isExtraImport": true,
        "detail": "AeViz.plot_utils.plot_creation",
        "documentation": {}
    },
    {
        "label": "ticker",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "LogNorm",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "SymLogNorm",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "Normalize",
        "importPath": "matplotlib.colors",
        "description": "matplotlib.colors",
        "isExtraImport": true,
        "detail": "matplotlib.colors",
        "documentation": {}
    },
    {
        "label": "Data",
        "importPath": "AeViz.load_utils.data_load_utils",
        "description": "AeViz.load_utils.data_load_utils",
        "isExtraImport": true,
        "detail": "AeViz.load_utils.data_load_utils",
        "documentation": {}
    },
    {
        "label": "PlottingUtils",
        "importPath": "AeViz.plot_utils.plotting_utils",
        "description": "AeViz.plot_utils.plotting_utils",
        "isExtraImport": true,
        "detail": "AeViz.plot_utils.plotting_utils",
        "documentation": {}
    },
    {
        "label": "PlottingUtils",
        "importPath": "AeViz.plot_utils.plotting_utils",
        "description": "AeViz.plot_utils.plotting_utils",
        "isExtraImport": true,
        "detail": "AeViz.plot_utils.plotting_utils",
        "documentation": {}
    },
    {
        "label": "grid",
        "importPath": "AeViz.grid.grid",
        "description": "AeViz.grid.grid",
        "isExtraImport": true,
        "detail": "AeViz.grid.grid",
        "documentation": {}
    },
    {
        "label": "function_average",
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "strfct2D",
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "IDL_derivative",
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "function_average",
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "IDL_derivative",
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "function_average_radii",
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "function_average",
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "IDL_derivative",
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "IDL_derivative",
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "pltf",
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "simulation_local_storage_folder",
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "find_simulation",
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "load_file",
        "importPath": "AeViz.utils.file_utils",
        "description": "AeViz.utils.file_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.file_utils",
        "documentation": {}
    },
    {
        "label": "load_file",
        "importPath": "AeViz.utils.file_utils",
        "description": "AeViz.utils.file_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.file_utils",
        "documentation": {}
    },
    {
        "label": "find_column_changing_line",
        "importPath": "AeViz.utils.file_utils",
        "description": "AeViz.utils.file_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.file_utils",
        "documentation": {}
    },
    {
        "label": "save_hdf",
        "importPath": "AeViz.utils.file_utils",
        "description": "AeViz.utils.file_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.file_utils",
        "documentation": {}
    },
    {
        "label": "save_hdf",
        "importPath": "AeViz.utils.file_utils",
        "description": "AeViz.utils.file_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.file_utils",
        "documentation": {}
    },
    {
        "label": "save_hdf",
        "importPath": "AeViz.utils.file_utils",
        "description": "AeViz.utils.file_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.file_utils",
        "documentation": {}
    },
    {
        "label": "save_hdf",
        "importPath": "AeViz.utils.file_utils",
        "description": "AeViz.utils.file_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.file_utils",
        "documentation": {}
    },
    {
        "label": "hdf_isopen",
        "importPath": "AeViz.utils.decorators",
        "description": "AeViz.utils.decorators",
        "isExtraImport": true,
        "detail": "AeViz.utils.decorators",
        "documentation": {}
    },
    {
        "label": "GW_strain",
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "calculate_h",
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GW_spectrogram",
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GWs_peak_indices",
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GWs_fourier_transform",
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GWs_frequency_peak_indices",
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "calculate_radius",
        "importPath": "AeViz.utils.load_save_radii_utils",
        "description": "AeViz.utils.load_save_radii_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.load_save_radii_utils",
        "documentation": {}
    },
    {
        "label": "calculate_radius",
        "importPath": "AeViz.utils.load_save_radii_utils",
        "description": "AeViz.utils.load_save_radii_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.load_save_radii_utils",
        "documentation": {}
    },
    {
        "label": "calculate_masses_energies",
        "importPath": "AeViz.utils.load_save_mass_ene_utils",
        "description": "AeViz.utils.load_save_mass_ene_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.load_save_mass_ene_utils",
        "documentation": {}
    },
    {
        "label": "calculate_profile",
        "importPath": "AeViz.utils.profiles",
        "description": "AeViz.utils.profiles",
        "isExtraImport": true,
        "detail": "AeViz.utils.profiles",
        "documentation": {}
    },
    {
        "label": "calculate_profile",
        "importPath": "AeViz.utils.profiles",
        "description": "AeViz.utils.profiles",
        "isExtraImport": true,
        "detail": "AeViz.utils.profiles",
        "documentation": {}
    },
    {
        "label": "stft",
        "importPath": "scipy.signal",
        "description": "scipy.signal",
        "isExtraImport": true,
        "detail": "scipy.signal",
        "documentation": {}
    },
    {
        "label": "sph_harm",
        "importPath": "scipy.special",
        "description": "scipy.special",
        "isExtraImport": true,
        "detail": "scipy.special",
        "documentation": {}
    },
    {
        "label": "factorial",
        "importPath": "scipy.special",
        "description": "scipy.special",
        "isExtraImport": true,
        "detail": "scipy.special",
        "documentation": {}
    },
    {
        "label": "binom",
        "importPath": "scipy.special",
        "description": "scipy.special",
        "isExtraImport": true,
        "detail": "scipy.special",
        "documentation": {}
    },
    {
        "label": "fft",
        "importPath": "numpy.fft",
        "description": "numpy.fft",
        "isExtraImport": true,
        "detail": "numpy.fft",
        "documentation": {}
    },
    {
        "label": "fftfreq",
        "importPath": "numpy.fft",
        "description": "numpy.fft",
        "isExtraImport": true,
        "detail": "numpy.fft",
        "documentation": {}
    },
    {
        "label": "check_existence",
        "importPath": "AeViz.utils.utils",
        "description": "AeViz.utils.utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.utils",
        "documentation": {}
    },
    {
        "label": "progressBar",
        "importPath": "AeViz.utils.utils",
        "description": "AeViz.utils.utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.utils",
        "documentation": {}
    },
    {
        "label": "check_existence",
        "importPath": "AeViz.utils.utils",
        "description": "AeViz.utils.utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.utils",
        "documentation": {}
    },
    {
        "label": "progressBar",
        "importPath": "AeViz.utils.utils",
        "description": "AeViz.utils.utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.utils",
        "documentation": {}
    },
    {
        "label": "progressBar",
        "importPath": "AeViz.utils.utils",
        "description": "AeViz.utils.utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.utils",
        "documentation": {}
    },
    {
        "label": "check_existence",
        "importPath": "AeViz.utils.utils",
        "description": "AeViz.utils.utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.utils",
        "documentation": {}
    },
    {
        "label": "check_existence",
        "importPath": "AeViz.utils.utils",
        "description": "AeViz.utils.utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.utils",
        "documentation": {}
    },
    {
        "label": "progressBar",
        "importPath": "AeViz.utils.utils",
        "description": "AeViz.utils.utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.utils",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "innercore_mass_energy",
        "importPath": "AeViz.utils.masses_energies_utils",
        "description": "AeViz.utils.masses_energies_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.masses_energies_utils",
        "documentation": {}
    },
    {
        "label": "gain_region_mass_energy",
        "importPath": "AeViz.utils.masses_energies_utils",
        "description": "AeViz.utils.masses_energies_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.masses_energies_utils",
        "documentation": {}
    },
    {
        "label": "PNS_mass_energy",
        "importPath": "AeViz.utils.masses_energies_utils",
        "description": "AeViz.utils.masses_energies_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.masses_energies_utils",
        "documentation": {}
    },
    {
        "label": "unbound_mass_energy",
        "importPath": "AeViz.utils.masses_energies_utils",
        "description": "AeViz.utils.masses_energies_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.masses_energies_utils",
        "documentation": {}
    },
    {
        "label": "mass_flux",
        "importPath": "AeViz.utils.masses_energies_utils",
        "description": "AeViz.utils.masses_energies_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.masses_energies_utils",
        "documentation": {}
    },
    {
        "label": "AeViz.utils.radii_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "PNS_radius",
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "innercore_radius",
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "gain_radius",
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "neutrino_sphere_radii",
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "PNS_nucleus",
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "shock_radius",
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "isExtraImport": true,
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "f90nml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "f90nml",
        "description": "f90nml",
        "detail": "f90nml",
        "documentation": {}
    },
    {
        "label": "sys,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys.",
        "description": "sys.",
        "detail": "sys.",
        "documentation": {}
    },
    {
        "label": "Plotting",
        "importPath": "AeViz.quantities_plotting.plotting",
        "description": "AeViz.quantities_plotting.plotting",
        "isExtraImport": true,
        "detail": "AeViz.quantities_plotting.plotting",
        "documentation": {}
    },
    {
        "label": "cell",
        "kind": 6,
        "importPath": "AeViz.cell.cell",
        "description": "AeViz.cell.cell",
        "peekOfCode": "class cell:\n    \"\"\"\n    Class that allows to get the grid related quantities\n    Initialization parameters:\n        path_folder: (string) path to the simulation folder\n        dim: (int, optional) dimension of the supernova simulation (1, 2, or 3)\n    \"\"\"\n    def __init__(self, path_folder=None, dim=None,\n                 radius=None, theta=None, phi=None):\n        assert dim in (1, 2, 3, None), \"Supernova simulation can either be 1D, 2D or 3D\"",
        "detail": "AeViz.cell.cell",
        "documentation": {}
    },
    {
        "label": "ghost",
        "kind": 6,
        "importPath": "AeViz.cell.ghost",
        "description": "AeViz.cell.ghost",
        "peekOfCode": "class ghost:\n    \"\"\"\n    Class that allows to remove the selected number of ghost cell from\n    an array.\n    Input parameters:\n            ghost_cells: (int) number of ghost cell of the simulation (usually 4)\n    Parameters:\n            ghost: (int) number of ghost cells\n            r_l: (int) ghost cells at the beginning of the radius array\n            r_r: (int) ghost cells at the end of the radius array",
        "detail": "AeViz.cell.ghost",
        "documentation": {}
    },
    {
        "label": "grid",
        "kind": 6,
        "importPath": "AeViz.grid.grid",
        "description": "AeViz.grid.grid",
        "peekOfCode": "class grid:\n    \"\"\"\n    Class to compute a cartesian grid from spherical coordinates.\n    BEWARE: is also possible to obtain a finer (o larger) grid and then\n    interpolate the desired quantity to it, HOWEVER, it works only for\n    1D and 2D cases.\n    parameters:\n        dim: (int) simulation dimension, MUST be in (1, 2, 3)\n        radius: (float, numpy array) radius of the spherical simulation\n        theta: (float, numpy array) polar angle",
        "detail": "AeViz.grid.grid",
        "documentation": {}
    },
    {
        "label": "Data",
        "kind": 6,
        "importPath": "AeViz.load_utils.data_load_utils",
        "description": "AeViz.load_utils.data_load_utils",
        "peekOfCode": "class Data(object):\n    def __init__(self):\n        self.loaded_data = None\n        self.hydroTHD_index, self.gh_cells = None, None\n        self.sim_dim = None\n    def Load(self, path, simulation_path=None, dim=None):\n        self.data_type = check_file_to_load(path)\n        if self.data_type == 'hdf5':\n            self.__load_hdf(path)\n        elif self.data_type == 'sim':",
        "detail": "AeViz.load_utils.data_load_utils",
        "documentation": {}
    },
    {
        "label": "check_file_to_load",
        "kind": 2,
        "importPath": "AeViz.load_utils.data_load_utils",
        "description": "AeViz.load_utils.data_load_utils",
        "peekOfCode": "def check_file_to_load(path):\n    if path.endswith('.hdf5') or path.endswith('.h5') or path.endswith('.hdf'):\n        return 'hdf5'\n    elif not os.path.exists(path):\n        return 'sim'\ndef return_index(hydro_dict, name):\n    convert_dict = {\n        'RHO': {'type': 'hydro/data', 'index': hydro_dict['hydro']['I_RH']},\n        'ENE': {'type': 'hydro/data', 'index': hydro_dict['hydro']['I_EN']},\n        'VX': {'type': 'hydro/data', 'index': hydro_dict['hydro']['I_VX']},",
        "detail": "AeViz.load_utils.data_load_utils",
        "documentation": {}
    },
    {
        "label": "return_index",
        "kind": 2,
        "importPath": "AeViz.load_utils.data_load_utils",
        "description": "AeViz.load_utils.data_load_utils",
        "peekOfCode": "def return_index(hydro_dict, name):\n    convert_dict = {\n        'RHO': {'type': 'hydro/data', 'index': hydro_dict['hydro']['I_RH']},\n        'ENE': {'type': 'hydro/data', 'index': hydro_dict['hydro']['I_EN']},\n        'VX': {'type': 'hydro/data', 'index': hydro_dict['hydro']['I_VX']},\n        'VY': {'type': 'hydro/data', 'index': hydro_dict['hydro']['I_VY']},\n        'VZ': {'type': 'hydro/data', 'index': hydro_dict['hydro']['I_VZ']},\n        'YE': {'type': 'hydro/data', 'index': hydro_dict['hydro']['I_YE']},\n        'YN': {'type': 'hydro/data', 'index': hydro_dict['hydro']['I_YN']},\n        'ERR': {'type': 'thd/data', 'index': hydro_dict['thd']['I_EOSERR']},",
        "detail": "AeViz.load_utils.data_load_utils",
        "documentation": {}
    },
    {
        "label": "u",
        "kind": 5,
        "importPath": "AeViz.load_utils.data_load_utils",
        "description": "AeViz.load_utils.data_load_utils",
        "peekOfCode": "u = units()\ndef check_file_to_load(path):\n    if path.endswith('.hdf5') or path.endswith('.h5') or path.endswith('.hdf'):\n        return 'hdf5'\n    elif not os.path.exists(path):\n        return 'sim'\ndef return_index(hydro_dict, name):\n    convert_dict = {\n        'RHO': {'type': 'hydro/data', 'index': hydro_dict['hydro']['I_RH']},\n        'ENE': {'type': 'hydro/data', 'index': hydro_dict['hydro']['I_EN']},",
        "detail": "AeViz.load_utils.data_load_utils",
        "documentation": {}
    },
    {
        "label": "PlotCreation",
        "kind": 6,
        "importPath": "AeViz.plot_utils.plot_creation",
        "description": "AeViz.plot_utils.plot_creation",
        "peekOfCode": "class PlotCreation(object):\n    def __init__(self):\n        self.fig = None\n        self.axd = None\n        self.number = None\n        self.form_factor = None\n    def __setup_figure(self):\n        if not self.fig_is_open():\n            self.fig = plt.figure()\n    def fig_is_open(self):",
        "detail": "AeViz.plot_utils.plot_creation",
        "documentation": {}
    },
    {
        "label": "return_positioning",
        "kind": 2,
        "importPath": "AeViz.plot_utils.plot_creation",
        "description": "AeViz.plot_utils.plot_creation",
        "peekOfCode": "def return_positioning(number, form_factor):\n    positioning = {1: {1: \"\"\"A\"\"\",\n                       2: \"\"\"A.a\"\"\"},\n                   2: {1: \"\"\"AB\"\"\",\n                       2: \"\"\"a.AB.b\"\"\",\n                       3: \"\"\"A\n                             B\"\"\",\n                       4: \"\"\"A.a\n                             B.b\"\"\",\n                       },",
        "detail": "AeViz.plot_utils.plot_creation",
        "documentation": {}
    },
    {
        "label": "return_fig_size",
        "kind": 2,
        "importPath": "AeViz.plot_utils.plot_creation",
        "description": "AeViz.plot_utils.plot_creation",
        "peekOfCode": "def return_fig_size(number, form_factor):\n    fig_size = {1: {1: (8, 8),\n                    2: (8, 8)},\n                2: {1: (8, 8),\n                    2: (8, 8),\n                    3: (8, 8),\n                    4: (8, 8)},\n                3: {1: (9, 8.42),\n                    2: (9, 8.42)},\n                4: {1: (8, 4),",
        "detail": "AeViz.plot_utils.plot_creation",
        "documentation": {}
    },
    {
        "label": "change_y_cbar_aspect",
        "kind": 2,
        "importPath": "AeViz.plot_utils.plot_creation",
        "description": "AeViz.plot_utils.plot_creation",
        "peekOfCode": "def change_y_cbar_aspect(axd, axd_bar):\n    axd_position = axd.get_position()\n    y0, y1 = axd_position.y0, axd_position.y1\n    bar_position = axd_bar.get_position()\n    bar_position.y0, bar_position.y1 = y0, y1\n    axd_bar.set_position(bar_position)\ndef change_x_cbar_aspect(axd, axd_bar):\n    axd_position = axd.get_position()\n    x0, x1 = axd_position.x0, axd_position.x1\n    bar_position = axd_bar.get_position()",
        "detail": "AeViz.plot_utils.plot_creation",
        "documentation": {}
    },
    {
        "label": "change_x_cbar_aspect",
        "kind": 2,
        "importPath": "AeViz.plot_utils.plot_creation",
        "description": "AeViz.plot_utils.plot_creation",
        "peekOfCode": "def change_x_cbar_aspect(axd, axd_bar):\n    axd_position = axd.get_position()\n    x0, x1 = axd_position.x0, axd_position.x1\n    bar_position = axd_bar.get_position()\n    bar_position.x0, bar_position.x1 = x0, x1\n    axd_bar.set_position(bar_position)\ndef change_x_aspect(axd, axd_left, axd_right):\n    axd_position = axd.get_position()\n    axd_left_position = axd_left.get_position()\n    axd_right_position = axd_right.get_position()",
        "detail": "AeViz.plot_utils.plot_creation",
        "documentation": {}
    },
    {
        "label": "change_x_aspect",
        "kind": 2,
        "importPath": "AeViz.plot_utils.plot_creation",
        "description": "AeViz.plot_utils.plot_creation",
        "peekOfCode": "def change_x_aspect(axd, axd_left, axd_right):\n    axd_position = axd.get_position()\n    axd_left_position = axd_left.get_position()\n    axd_right_position = axd_right.get_position()\n    axd_position.x0, axd_position.x1 = axd_left_position.x0, axd_right_position.x1\n    axd.set_position(axd_position)\ndef change_y_aspect(axd, axd_bottom, axd_top):\n    axd_position = axd.get_position()\n    axd_bottom_position = axd_bottom.get_position()\n    axd_top_position = axd_top.get_position()",
        "detail": "AeViz.plot_utils.plot_creation",
        "documentation": {}
    },
    {
        "label": "change_y_aspect",
        "kind": 2,
        "importPath": "AeViz.plot_utils.plot_creation",
        "description": "AeViz.plot_utils.plot_creation",
        "peekOfCode": "def change_y_aspect(axd, axd_bottom, axd_top):\n    axd_position = axd.get_position()\n    axd_bottom_position = axd_bottom.get_position()\n    axd_top_position = axd_top.get_position()\n    axd_position.y0, axd_position.y1 = axd_bottom_position.y0, axd_top_position.y1\n    axd.set_position(axd_position)\nclass PlotCreation(object):\n    def __init__(self):\n        self.fig = None\n        self.axd = None",
        "detail": "AeViz.plot_utils.plot_creation",
        "documentation": {}
    },
    {
        "label": "PlottingUtils",
        "kind": 6,
        "importPath": "AeViz.plot_utils.plotting_utils",
        "description": "AeViz.plot_utils.plotting_utils",
        "peekOfCode": "class PlottingUtils(PlotCreation):\n    def __init__(self):\n        self.__reset_params()\n        PlotCreation.__init__(self)     \n    def __update_params(self, ax_letter, grid, data, cbar_position, \n                        cbar_log, cbar_levels, dim, cmap, cbar_label):\n        self.grid[ax_letter] = grid\n        self.cbar_position[ax_letter] = cbar_position\n        self.cbar_log[ax_letter] = cbar_log\n        self.cbar_lv[ax_letter] = cbar_levels",
        "detail": "AeViz.plot_utils.plotting_utils",
        "documentation": {}
    },
    {
        "label": "cbar_loaction",
        "kind": 2,
        "importPath": "AeViz.plot_utils.plotting_utils",
        "description": "AeViz.plot_utils.plotting_utils",
        "peekOfCode": "def cbar_loaction(loc):\n    location = {'T': 'top', 'B': 'bottom', 'L': 'left', 'R': 'right'}\n    return location[loc]\ndef set2Dlims(ax, xlim, ylim, number, form_factor):\n    if xlim==None:\n        ylim = list(ylim)\n        ylim.sort()\n        xlim = [0]\n        if number == 4 and form_factor == 2:\n            ylim[0] = 0",
        "detail": "AeViz.plot_utils.plotting_utils",
        "documentation": {}
    },
    {
        "label": "set2Dlims",
        "kind": 2,
        "importPath": "AeViz.plot_utils.plotting_utils",
        "description": "AeViz.plot_utils.plotting_utils",
        "peekOfCode": "def set2Dlims(ax, xlim, ylim, number, form_factor):\n    if xlim==None:\n        ylim = list(ylim)\n        ylim.sort()\n        xlim = [0]\n        if number == 4 and form_factor == 2:\n            ylim[0] = 0\n        else:\n            ylim[0] = -ylim[1]\n        xlim.append(ylim[1])",
        "detail": "AeViz.plot_utils.plotting_utils",
        "documentation": {}
    },
    {
        "label": "Plotting",
        "kind": 6,
        "importPath": "AeViz.quantities_plotting.plotting",
        "description": "AeViz.quantities_plotting.plotting",
        "peekOfCode": "class Plotting(PlottingUtils, Data):\n    def __init__(self):\n        PlottingUtils.__init__(self)\n        Data.__init__(self)\n    def  plot1D(self, qt, xaxis, index1, index2):\n        axd_letters = ['A', 'B', 'C', 'D']\n        number = self.__check_axd_1D(qt, xaxis)\n        post_data = self._Data__get_data_from_name(qt)\n        if xaxis == 'radius':\n            grid = u.convert_to_km(self.cell.radius(self.ghost))",
        "detail": "AeViz.quantities_plotting.plotting",
        "documentation": {}
    },
    {
        "label": "recognize_quantity",
        "kind": 2,
        "importPath": "AeViz.quantities_plotting.plotting",
        "description": "AeViz.quantities_plotting.plotting",
        "peekOfCode": "def recognize_quantity(qt1, qt2, qt3, qt4, pars):\n    if qt1 == 'NUE':\n        qt1, qt2, qt3, qt4 = 'NUEX', 'NUEY', 'NUEZ', 'NUEE'\n    if qt1 == 'NUA':\n        qt1, qt2, qt3, qt4 = 'NUAX', 'NUAY', 'NUAZ', 'NUAE'\n    if qt1 == 'NUX':\n        qt1, qt2, qt3, qt4 = 'NUXX', 'NUXY', 'NUXZ', 'NUXE'\n    if qt1 == 'B':\n        qt1, qt2, qt3, qt4 = 'BX', 'BY', 'BZ', None\n    if pars:",
        "detail": "AeViz.quantities_plotting.plotting",
        "documentation": {}
    },
    {
        "label": "setup_cbars",
        "kind": 2,
        "importPath": "AeViz.quantities_plotting.plotting",
        "description": "AeViz.quantities_plotting.plotting",
        "peekOfCode": "def setup_cbars(qt1, qt2, qt3, qt4):\n    if qt4 is not None or qt3 is not None:\n        number, form_factor = 4, 2\n        cbars = {'A': 'T', 'B': 'B', 'C': 'T', 'D': 'B'}\n    elif qt2 is not None:\n        number, form_factor = 2, 2\n        cbars = {'A': 'L', 'B': 'R'}\n    elif qt1 is not None:\n        number, form_factor = 1, 2\n        cbars = {'A': 'R'}",
        "detail": "AeViz.quantities_plotting.plotting",
        "documentation": {}
    },
    {
        "label": "normalize_indices",
        "kind": 2,
        "importPath": "AeViz.quantities_plotting.plotting",
        "description": "AeViz.quantities_plotting.plotting",
        "peekOfCode": "def normalize_indices(index1, index2):\n    if type(index1) == range:\n        index1 = list(index1)\n    if type(index2) == range:\n        index2 = list(index2)\n    if type(index1) == list and type(index2) == list:\n        index2 = index2[0]\n    return index1, index2\ndef get_data_to_plot(index1, index2, post_data, xaxis, dV):\n    if post_data.ndim == 1:",
        "detail": "AeViz.quantities_plotting.plotting",
        "documentation": {}
    },
    {
        "label": "get_data_to_plot",
        "kind": 2,
        "importPath": "AeViz.quantities_plotting.plotting",
        "description": "AeViz.quantities_plotting.plotting",
        "peekOfCode": "def get_data_to_plot(index1, index2, post_data, xaxis, dV):\n    if post_data.ndim == 1:\n        data = post_data\n    elif post_data.ndim == 2:\n        if xaxis == 'radius':\n            if type(index1) == list:\n                data = []\n                for i in index1:\n                    data.append(post_data[i, :])\n            elif index1 is None:",
        "detail": "AeViz.quantities_plotting.plotting",
        "documentation": {}
    },
    {
        "label": "u",
        "kind": 5,
        "importPath": "AeViz.quantities_plotting.plotting",
        "description": "AeViz.quantities_plotting.plotting",
        "peekOfCode": "u = units()\nplot_labels = {'RHO': {'log': True, 'lim': (1e4, 1e15), 'cmap': 'viridis', 'label': r'$\\rho$ [g$\\cdot$cm$^{-3}$]'},\n        'ENE': {'log': True, 'lim': (1e24, 1e35), 'cmap': 'nipy_spectral', 'label': r'$E$ [erg]'},\n        'VX': {'log': True, 'lim': (-1e10, 5e10), 'cmap': 'Spectral_r', 'label': r'$v_r$ [cm$\\cdot$s$^{-1}$]'},\n        'VY': {'log': True, 'lim': (-1e10, 1e10), 'cmap': 'Spectral_r', 'label': r'$v_\\theta$ [cm$\\cdot$s$^{-1}$]'},\n        'VZ': {'log': True, 'lim': (1e7, 1e10), 'cmap': 'cividis', 'label': r'$v_\\phi$ [cm$\\cdot$s$^{-1}$]'},\n        'YE': {'log': False, 'lim': (0.0, 0.5), 'cmap': 'gist_rainbow', 'label': r'Y$_e$'},\n        'YN': {'log': False, 'lim': (0, 1.0), 'cmap': 'gist_rainbow', 'label': r'Y$_N$'},\n        'ERR': {'log': False, 'lim': (0, 1), 'cmap': 'seismic', 'label': r'Error'},\n        'LRTZ': {'log': False, 'lim': (1, 1.1), 'cmap': 'gist_rainbow', 'label': r'$\\gamma$'},",
        "detail": "AeViz.quantities_plotting.plotting",
        "documentation": {}
    },
    {
        "label": "plot_labels",
        "kind": 5,
        "importPath": "AeViz.quantities_plotting.plotting",
        "description": "AeViz.quantities_plotting.plotting",
        "peekOfCode": "plot_labels = {'RHO': {'log': True, 'lim': (1e4, 1e15), 'cmap': 'viridis', 'label': r'$\\rho$ [g$\\cdot$cm$^{-3}$]'},\n        'ENE': {'log': True, 'lim': (1e24, 1e35), 'cmap': 'nipy_spectral', 'label': r'$E$ [erg]'},\n        'VX': {'log': True, 'lim': (-1e10, 5e10), 'cmap': 'Spectral_r', 'label': r'$v_r$ [cm$\\cdot$s$^{-1}$]'},\n        'VY': {'log': True, 'lim': (-1e10, 1e10), 'cmap': 'Spectral_r', 'label': r'$v_\\theta$ [cm$\\cdot$s$^{-1}$]'},\n        'VZ': {'log': True, 'lim': (1e7, 1e10), 'cmap': 'cividis', 'label': r'$v_\\phi$ [cm$\\cdot$s$^{-1}$]'},\n        'YE': {'log': False, 'lim': (0.0, 0.5), 'cmap': 'gist_rainbow', 'label': r'Y$_e$'},\n        'YN': {'log': False, 'lim': (0, 1.0), 'cmap': 'gist_rainbow', 'label': r'Y$_N$'},\n        'ERR': {'log': False, 'lim': (0, 1), 'cmap': 'seismic', 'label': r'Error'},\n        'LRTZ': {'log': False, 'lim': (1, 1.1), 'cmap': 'gist_rainbow', 'label': r'$\\gamma$'},\n        'DENS': {'log': True, 'lim': (1e4, 1e15), 'cmap': 'viridis', 'label': r'$\\rho$ [g cm$^{-3}$]'},",
        "detail": "AeViz.quantities_plotting.plotting",
        "documentation": {}
    },
    {
        "label": "xaxis_labels",
        "kind": 5,
        "importPath": "AeViz.quantities_plotting.plotting",
        "description": "AeViz.quantities_plotting.plotting",
        "peekOfCode": "xaxis_labels = {'radius': 'R [km]', 'theta': r'$\\theta$ [rad]', 'phi': r'$\\phi$ [rad]', 'time': 't [s]'}\ndef recognize_quantity(qt1, qt2, qt3, qt4, pars):\n    if qt1 == 'NUE':\n        qt1, qt2, qt3, qt4 = 'NUEX', 'NUEY', 'NUEZ', 'NUEE'\n    if qt1 == 'NUA':\n        qt1, qt2, qt3, qt4 = 'NUAX', 'NUAY', 'NUAZ', 'NUAE'\n    if qt1 == 'NUX':\n        qt1, qt2, qt3, qt4 = 'NUXX', 'NUXY', 'NUXZ', 'NUXE'\n    if qt1 == 'B':\n        qt1, qt2, qt3, qt4 = 'BX', 'BY', 'BZ', None",
        "detail": "AeViz.quantities_plotting.plotting",
        "documentation": {}
    },
    {
        "label": "Simulation",
        "kind": 6,
        "importPath": "AeViz.simulation.simulation",
        "description": "AeViz.simulation.simulation",
        "peekOfCode": "class Simulation:\n    def __init__(self, simulation_name, simulation_folder_path=None,\n                 dim = None):\n        \"\"\"\n        Simulation class initialization. Attibutes:\n        \"\"\"\n        ## Public attributes\n        self.simulation_name = simulation_name\n        self.path = find_simulation(self.simulation_name, pltf(),\n                                    simulation_folder_path)",
        "detail": "AeViz.simulation.simulation",
        "documentation": {}
    },
    {
        "label": "u",
        "kind": 5,
        "importPath": "AeViz.simulation.simulation",
        "description": "AeViz.simulation.simulation",
        "peekOfCode": "u = units()\nclass Simulation:\n    def __init__(self, simulation_name, simulation_folder_path=None,\n                 dim = None):\n        \"\"\"\n        Simulation class initialization. Attibutes:\n        \"\"\"\n        ## Public attributes\n        self.simulation_name = simulation_name\n        self.path = find_simulation(self.simulation_name, pltf(),",
        "detail": "AeViz.simulation.simulation",
        "documentation": {}
    },
    {
        "label": "units",
        "kind": 6,
        "importPath": "AeViz.units.units",
        "description": "AeViz.units.units",
        "peekOfCode": "class units:\n    \"\"\"\n    Class with the various conversion units and constants in cgs.\n    \"\"\"\n    def __init__(self):\n        self.solar_mass = 1.98847e33 #g\n        self.speed_light = 2.99792458e10 #cm/s\n        self.MeV = 1.360218e-6 #erg\n        self.km = 1e5 #cm\n        self.ms = 1e-3 #s",
        "detail": "AeViz.units.units",
        "documentation": {}
    },
    {
        "label": "GW_strain",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def GW_strain(sim_dim, column_change, data, index):\n    assert sim_dim in [1, 2, 3], \"Simulation MUST be 1, 2 or 3D.\"\n    if sim_dim == 1:\n        return GW_strain_1D(data)\n    elif sim_dim == 2:\n        return correct_zero(2, GW_strain_2D(data), index)\n    else:\n        GWs = GW_strain_3D(data)\n        if column_change is not None:\n            GWs[:column_change, 1] = GW_strain_2D(data)[:column_change, 1]",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GW_strain_1D",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def GW_strain_1D(data):\n    print(\"No GW for you :'(\")\n    return None\ndef GW_strain_2D(data):\n    \"\"\"\n        GWs amplitudes calculated as the first partial time derivative\n        of NE_220 and not with the second partial time derivative of \n        ME_220. Moreover, we only consider matter contribution to the \n        amplitude, being the main contribution to it.\n    \"\"\"",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GW_strain_2D",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def GW_strain_2D(data):\n    \"\"\"\n        GWs amplitudes calculated as the first partial time derivative\n        of NE_220 and not with the second partial time derivative of \n        ME_220. Moreover, we only consider matter contribution to the \n        amplitude, being the main contribution to it.\n    \"\"\"\n    const = -0.125 *  np.sqrt(15/np.pi)\n    return np.stack((data[:, 2], const * IDL_derivative(data[:,2], data[:,5])),\n              axis = 1)",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GW_strain_3D",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def GW_strain_3D(data):\n    const = 1 #8 * np.sqrt(np.pi / 15)\n    hD_pl_p = 2. * ( data[:,9] - data[:,13] )\n    hD_pl_e = 2. * ( data[:,17] - data[:,13] )\n    hD_cr_p = 2. * ( data[:,10] + data[:,12] )\n    hD_cr_e = 2. * ( - data[:,14] - data[:,16] )\n    hD_pl_p = const * IDL_derivative( data[:,2], hD_pl_p )\n    hD_cr_p = const * IDL_derivative( data[:,2], hD_cr_p )\n    hD_pl_e = const * IDL_derivative( data[:,2], hD_pl_e )\n    hD_cr_e = const * IDL_derivative( data[:,2], hD_cr_e )",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "correct_zero",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def correct_zero(sim_dim, GWs, index):\n    if sim_dim == 1:\n        pass\n    else:\n        if index is None:\n            return GWs\n        for i in range(1, GWs.shape[1]):\n            GWs[:, i] -= GWs[:index, i].mean()\n        return GWs\n## ---------------------------------------------------------------------",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GW_spectrogram",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def GW_spectrogram(sim_dim, GWs, window_size):\n    assert sim_dim in [1, 2, 3], \"Simulation MUST be 1, 2 or 3D.\"\n    if sim_dim == 1:\n        return GW_spectrogram_1D(GWs)\n    elif sim_dim == 2:\n        return GW_spectrogram_2D(GWs, window_size)\n    else:\n        return GW_spectrogram_3D(GWs, window_size)\ndef GW_spectrogram_1D(GWs):\n    print(\"And also no spectrogram for you :'(\\nごめんなさい\")",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GW_spectrogram_1D",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def GW_spectrogram_1D(GWs):\n    print(\"And also no spectrogram for you :'(\\nごめんなさい\")\n    return None\ndef GW_spectrogram_2D(GWs, window_size):\n    \"\"\"\n    \"\"\"\n    fs = (GWs[1, 0] - GWs[0, 0]) ** (-1)\n    frequency, time, Zxx = stft(GWs[:,1], fs = fs, nperseg=window_size)\n    time = time / time[-1] * GWs[-1, 0]\n    return time, frequency, np.abs(Zxx)",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GW_spectrogram_2D",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def GW_spectrogram_2D(GWs, window_size):\n    \"\"\"\n    \"\"\"\n    fs = (GWs[1, 0] - GWs[0, 0]) ** (-1)\n    frequency, time, Zxx = stft(GWs[:,1], fs = fs, nperseg=window_size)\n    time = time / time[-1] * GWs[-1, 0]\n    return time, frequency, np.abs(Zxx)\ndef GW_spectrogram_3D(GWs, window_size):\n    fs = (GWs[1, 0] - GWs[0, 0]) ** (-1)\n    freq_pl_e, time_pl_e, Zxx_pl_e = stft(GWs[:,1], fs=fs, nperseg=window_size)",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GW_spectrogram_3D",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def GW_spectrogram_3D(GWs, window_size):\n    fs = (GWs[1, 0] - GWs[0, 0]) ** (-1)\n    freq_pl_e, time_pl_e, Zxx_pl_e = stft(GWs[:,1], fs=fs, nperseg=window_size)\n    time_pl_e = time_pl_e / time_pl_e[-1] * GWs[-1, 0]\n    freq_pl_p, time_pl_p, Zxx_pl_p = stft(GWs[:,2], fs=fs, nperseg=window_size)\n    time_pl_p = time_pl_p / time_pl_p[-1] * GWs[-1, 0]\n    freq_cr_e, time_cr_e, Zxx_cr_e = stft(GWs[:,3], fs=fs, nperseg=window_size)\n    time_cr_e = time_cr_e / time_cr_e[-1] * GWs[-1, 0]\n    freq_cr_p, time_cr_p, Zxx_cr_p = stft(GWs[:,4], fs=fs, nperseg=window_size)\n    time_cr_p = time_cr_p / time_cr_p[-1] * GWs[-1, 0]",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GWs_peak_indices",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def GWs_peak_indices(GWs, peak, interval, min_time, max_time):\n    \"\"\"\n    Function that finds the coordinates of the minimum and maximum peak\n    of the equatorial + GW strain as well as the coordinates of the \n    points before and after the oscillation. Namely the latter are the \n    first intersection point with the x axis after the peak and the\n    third one before it.\n    Parameters:\n        peak: which peak to find, can be the bounce peak, highest in\n        an interval",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GWs_max_peak",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def GWs_max_peak(GWs, peak, interval, min_time, max_time):\n    \"\"\"\n    Function that finds the maximum value of the equatorial + \n    polarization of the GW strain as well as the time at which it\n    occurs.\n    \"\"\"\n    indices = GWs_peak_indices(GWs, peak, interval, min_time, max_time)\n    return GWs[indices[1], 0], GWs[indices[1], 1]\n## FREQUENCIES\ndef GWs_fourier_transform(GWs, indices):",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GWs_fourier_transform",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def GWs_fourier_transform(GWs, indices):\n    \"\"\"\n    This function applies FFT to a small portion of the GW strain to\n    find the domiunant frequency of a specific oscillation\n    Returns\n        positive frequency range\n        $\\tilde{h} * \\sqrt{freq}$\n    \"\"\"\n    dt = np.abs(GWs[1, 0] - GWs[0, 0])\n    ## Cut the GWs signal",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "GWs_frequency_peak_indices",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def GWs_frequency_peak_indices(frequency, htilde):\n    \"\"\"\n    Function: finds the indices of the first and second frequency\n    peak on a fourier transformed GW strain\n    Return:\n        list containing: first peak index, second peak index \n    \"\"\"\n    dhtilde_df = IDL_derivative(frequency, htilde)\n    sign = dhtilde_df[1:] * dhtilde_df[:-1]\n    ## Find extrema points",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "calculate_h",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def calculate_h(simulation, save_checkpoints=True):\n    \"\"\"\n    Calculates the h cross and x from postprocessing quantities for \n    every timestep of a simulation.\n    Returns\n        time: array of time step\n        AE220: len(radius), len(time) array\n        Full_strain: len(time) array\n        PNS_nucleus_strain: len(time) array\n        Convection_strain: len(time) array",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "NE220_2D",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def NE220_2D(simulation, file_name, dV, ctheta, inner_rad, igcells,\n          nuc_rad, ngcells):\n    \"\"\"\n    Calculates the NE220 from density and velocities for for as single\n    timestep. SAme process is employed in\n    \"\"\"\n    NE220 = dV * simulation.cell.radius(simulation.ghost) * \\\n        simulation.rho(file_name) * (simulation.radial_velocity(file_name) * \\\n        (3 * ctheta ** 2 - 1) - 3 * simulation.theta_velocity(file_name) * \\\n        ctheta * np.sqrt(1 - ctheta ** 2))",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "read_NE220",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def read_NE220(simulation):\n    \"\"\"\n    Reads the NE220 from a checkpoint file.\n    \"\"\"\n    data = h5py.File(os.path.join(simulation.storage_path, 'NE220.h5'), 'r')\n    time = data['time'][...]\n    NE220 = data['NE220'][...]\n    full_NE220 = data['full_NE220'][...]\n    nuc_NE220 = data['nucleus_NE220'][...]\n    conv_NE220 = data['convection_NE220'][...]",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "calculate_strain_2D",
        "kind": 2,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "def calculate_strain_2D(time, NE220, full_NE220, nuc_NE220, conv_NE220,\n                     outer_NE220):\n    \"\"\"\n    Derives ancd fixes the constants of the strain.\n    \"\"\"\n    const =  -0.125 *  np.sqrt(15/np.pi) * \\\n        (u.G * 16 * np.pi ** 0.5 / (np.sqrt( 15 ) * u.speed_light ** 4))\n    return time, const * IDL_derivative(time, NE220), const * \\\n        IDL_derivative(time, full_NE220), const * \\\n        IDL_derivative(time, nuc_NE220), const * \\",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "u",
        "kind": 5,
        "importPath": "AeViz.utils.GW_utils",
        "description": "AeViz.utils.GW_utils",
        "peekOfCode": "u = units()\n## ---------------------------------------------------------------------\n## GW strain\n## ---------------------------------------------------------------------\ndef GW_strain(sim_dim, column_change, data, index):\n    assert sim_dim in [1, 2, 3], \"Simulation MUST be 1, 2 or 3D.\"\n    if sim_dim == 1:\n        return GW_strain_1D(data)\n    elif sim_dim == 2:\n        return correct_zero(2, GW_strain_2D(data), index)",
        "detail": "AeViz.utils.GW_utils",
        "documentation": {}
    },
    {
        "label": "hdf_isopen",
        "kind": 2,
        "importPath": "AeViz.utils.decorators",
        "description": "AeViz.utils.decorators",
        "peekOfCode": "def hdf_isopen(func):\n    def wrapper(*args):\n        if args[1] != args[0]._Simulation__opened_hdf_file:\n            if args[0]._Simulation__data_h5 is not None:\n                args[0]._Simulation__data_h5.close()\n            if args[1] not in args[0].hdf_file_list:\n                raise ValueError(\"Selected file does not exist.\")\n            args[0]._Simulation__opened_hdf_file = args[1]\n            args[0]._Simulation__data_h5 = h5py.File(os.path.join(args[0]._Simulation__hdf_path, args[1]), 'r')\n        return func(*args)",
        "detail": "AeViz.utils.decorators",
        "documentation": {}
    },
    {
        "label": "load_file",
        "kind": 2,
        "importPath": "AeViz.utils.file_utils",
        "description": "AeViz.utils.file_utils",
        "peekOfCode": "def load_file(path_folder, file_name):\n    \"\"\"\n    Load data files, three attempts are made\n    - Attempt 1: use of loadtxt method of NumPy\n    - Attempt 2: use of loadtxt method of NumPy, reading only the first \n                 n columns, with n specified on the 2nd row of the .txt\n                 header file\n    - Attempt 3: use of Pandas to generate missing data\n    - Attempt 4: read file line by line filling a matrix with dimension \n                 NxM, where N is the number of rows in the file and M ",
        "detail": "AeViz.utils.file_utils",
        "documentation": {}
    },
    {
        "label": "find_column_changing_line",
        "kind": 2,
        "importPath": "AeViz.utils.file_utils",
        "description": "AeViz.utils.file_utils",
        "peekOfCode": "def find_column_changing_line(path_folder, file_name):\n    \"\"\"\n    Loads a data file and returns the number of the line at which\n    there is a numbero of columns change.\n    \"\"\"\n    path = os.path.join(path_folder, file_name)\n    assert os.path.exists(path), \"Selected file does not exists\"\n    number_of_colums = None\n    line_number = 1\n    with open(path, 'r') as f:",
        "detail": "AeViz.utils.file_utils",
        "documentation": {}
    },
    {
        "label": "save_hdf",
        "kind": 2,
        "importPath": "AeViz.utils.file_utils",
        "description": "AeViz.utils.file_utils",
        "peekOfCode": "def save_hdf(save_path, dataset_keywords, dataset_values):\n    \"\"\"\n    Save data in hdf format\n    dataset_keywords: list of strings, keywords for the datasets\n    dataset_values: list of whatever you want, these are the values for\n                    the datasets\n    \"\"\"\n    assert len(dataset_keywords) == len(dataset_values), \\\n        \"Number of keywords and values do not match\"\n    file_out = h5py.File(save_path, 'w')",
        "detail": "AeViz.utils.file_utils",
        "documentation": {}
    },
    {
        "label": "calculate_masses_energies",
        "kind": 2,
        "importPath": "AeViz.utils.load_save_mass_ene_utils",
        "description": "AeViz.utils.load_save_mass_ene_utils",
        "peekOfCode": "def calculate_masses_energies(simulation, save_checkpoints=True):\n    if check_existence(simulation, 'masses_energies.h5'):\n        time, mdot, inner_me, gain_me, PNS_me, unb_me = \\\n            read_masses_energies(simulation)\n        if len(simulation.hdf_file_list) == len(time):\n            return time, mdot, inner_me, gain_me, PNS_me, unb_me\n        else:\n            start_point = len(time)\n            print('Checkpoint found for the mass and energy file, starting' \\\n                  ' from checkpoint.\\nPlease wait...')",
        "detail": "AeViz.utils.load_save_mass_ene_utils",
        "documentation": {}
    },
    {
        "label": "read_masses_energies",
        "kind": 2,
        "importPath": "AeViz.utils.load_save_mass_ene_utils",
        "description": "AeViz.utils.load_save_mass_ene_utils",
        "peekOfCode": "def read_masses_energies(simulation):\n    masses_energies_data = h5py.File(os.path.join(simulation.storage_path, \n                                            'masses_energies.h5'), 'r')\n    data = [\n        masses_energies_data['time'][...],\n        masses_energies_data['mass_flux'][...],\n        {\n            'mass': masses_energies_data['innercore/mass'][...],\n            'kinetic_ene': masses_energies_data['innercore/kinetic_energy']\\\n                [...],",
        "detail": "AeViz.utils.load_save_mass_ene_utils",
        "documentation": {}
    },
    {
        "label": "calculate_radius",
        "kind": 2,
        "importPath": "AeViz.utils.load_save_radii_utils",
        "description": "AeViz.utils.load_save_radii_utils",
        "peekOfCode": "def calculate_radius(simulation, radius:Literal['PNS', 'innercore', 'gain', \n                                             'neutrino', 'shock', 'nucleus'],\n                     save_checkpoints=True):\n    \"\"\"\n    Calculates the selected radius for each timestep of the simulation.\n    In case of neutrinos, since in some cases are not saved for each\n    timestep, the timestep for which they are not saved is skipped.\n    If the save checkpoint flag is on, every 200 timesteps (for 3D\n    simulations) or 600 timesteps (for 2D simulations) the data is saved\n    in a hdf file.",
        "detail": "AeViz.utils.load_save_radii_utils",
        "documentation": {}
    },
    {
        "label": "read_radius",
        "kind": 2,
        "importPath": "AeViz.utils.load_save_radii_utils",
        "description": "AeViz.utils.load_save_radii_utils",
        "peekOfCode": "def read_radius(simulation, radius:Literal['PNS', 'innercore', 'gain', \n                                             'neutrino', 'shock', 'nucleus']):\n    \"\"\"\n    Reads the data from the hdf file. Returns a tuple containing:\n    (time, radii, max, min, avg, ghost_cells)\n    In case of neutrinos, radii, max, min and avg are dictionaries.\n    \"\"\"\n    radius_data = h5py.File(os.path.join(simulation.storage_path, \n                                            save_names[radius]), 'r')\n    if radius == 'neutrino':",
        "detail": "AeViz.utils.load_save_radii_utils",
        "documentation": {}
    },
    {
        "label": "functions",
        "kind": 5,
        "importPath": "AeViz.utils.load_save_radii_utils",
        "description": "AeViz.utils.load_save_radii_utils",
        "peekOfCode": "functions = {\n    'PNS': PNS_radius,\n    'innercore': innercore_radius,\n    'gain': gain_radius,\n    'neutrino': neutrino_sphere_radii,\n    'shock': shock_radius,\n    'nucleus': PNS_nucleus\n}\nsave_names = {\n    'PNS': 'PNS_radius.h5',",
        "detail": "AeViz.utils.load_save_radii_utils",
        "documentation": {}
    },
    {
        "label": "save_names",
        "kind": 5,
        "importPath": "AeViz.utils.load_save_radii_utils",
        "description": "AeViz.utils.load_save_radii_utils",
        "peekOfCode": "save_names = {\n    'PNS': 'PNS_radius.h5',\n    'innercore': 'innercore_radius.h5',\n    'gain': 'gain_radius.h5',\n    'neutrino': 'neutrino_sphere_radii.h5',\n    'shock': 'shock_radius.h5',\n    'nucleus': 'PNS_nucleus.h5'\n}\ndef calculate_radius(simulation, radius:Literal['PNS', 'innercore', 'gain', \n                                             'neutrino', 'shock', 'nucleus'],",
        "detail": "AeViz.utils.load_save_radii_utils",
        "documentation": {}
    },
    {
        "label": "innercore_mass_energy",
        "kind": 2,
        "importPath": "AeViz.utils.masses_energies_utils",
        "description": "AeViz.utils.masses_energies_utils",
        "peekOfCode": "def innercore_mass_energy(simulation, file_name, innercore_radius, gcells, dV):\n    \"\"\"\n    Calculates the mass, kinetic, magnetic, rotational, gravitational\n    and total energy and T/|W| of the inner core for one timestep.\n    \"\"\"\n    if simulation.dim == 1:\n        mask = (simulation.cell.radius(simulation.ghost) <= \\\n            innercore_radius)\n    else:\n        mask = (simulation.cell.radius(simulation.ghost) <= \\",
        "detail": "AeViz.utils.masses_energies_utils",
        "documentation": {}
    },
    {
        "label": {
            "name": "",
            "kind": 2,
            "peekOfCode": "def  gain_region_mass_energy(simulation, file_name, shock_radius, sgcells, \n                             gain_radius, ggcells, dV):\n    \"\"\"\n    Calculates the mass, neutrino heating energy of the gain region for\n    one timestep.\n    \"\"\"\n    if simulation.dim == 1:\n        mask = (simulation.cell.radius(simulation.ghost) >= \\\n            np.minimum(shock_radius, gain_radius)) & \\\n                (simulation.cell.radius(simulation.ghost) <= \\"
        },
        "kind": 2,
        "importPath": "AeViz.utils.masses_energies_utils",
        "description": "AeViz.utils.masses_energies_utils",
        "peekOfCode": "def  gain_region_mass_energy(simulation, file_name, shock_radius, sgcells, \n                             gain_radius, ggcells, dV):\n    \"\"\"\n    Calculates the mass, neutrino heating energy of the gain region for\n    one timestep.\n    \"\"\"\n    if simulation.dim == 1:\n        mask = (simulation.cell.radius(simulation.ghost) >= \\\n            np.minimum(shock_radius, gain_radius)) & \\\n                (simulation.cell.radius(simulation.ghost) <= \\",
        "detail": "AeViz.utils.masses_energies_utils",
        "documentation": {}
    },
    {
        "label": "PNS_mass_energy",
        "kind": 2,
        "importPath": "AeViz.utils.masses_energies_utils",
        "description": "AeViz.utils.masses_energies_utils",
        "peekOfCode": "def PNS_mass_energy(simulation, file_name, PNS_radius, gcells, dV):\n    \"\"\"\n    Calculates the mass, kinetic, magnetic, rotational, gravitational\n    and convective energy of the PNS for one timestep.\n    \"\"\"\n    if simulation.dim == 1:\n        mask = (simulation.cell.radius(simulation.ghost) >= \\\n            PNS_radius)\n    else:\n        mask = (simulation.cell.radius(simulation.ghost) >= \\",
        "detail": "AeViz.utils.masses_energies_utils",
        "documentation": {}
    },
    {
        "label": "unbound_mass_energy",
        "kind": 2,
        "importPath": "AeViz.utils.masses_energies_utils",
        "description": "AeViz.utils.masses_energies_utils",
        "peekOfCode": "def unbound_mass_energy(simulation, file_name, dV):\n    \"\"\"\n    Calculates the explosion energy and the unbound mass for one timestep.\n    \"\"\"\n    rho = simulation.rho(file_name)\n    mhd_ene = simulation.MHD_energy(file_name) + rho * \\\n        simulation.gravitational_potential(file_name)\n    mask = (mhd_ene > 0) & (simulation.cell.radius(simulation.ghost) < 1e10)\n    return u.convert_to_solar_masses(np.sum(rho[mask] * dV[mask])), \\\n        np.sum(mhd_ene[mask] * dV[mask])",
        "detail": "AeViz.utils.masses_energies_utils",
        "documentation": {}
    },
    {
        "label": "mass_flux",
        "kind": 2,
        "importPath": "AeViz.utils.masses_energies_utils",
        "description": "AeViz.utils.masses_energies_utils",
        "peekOfCode": "def mass_flux(simulation, file_name, dOmega, radius_index):\n    \"\"\"\n    Callulates the flow of matter at the index\n    \"\"\"\n    if simulation.dim == 1:\n        return -u.convert_to_solar_masses(4 * np.pi * \\\n                simulation.cell.radius(radius_index) ** 2 * np.sum( \\\n                simulation.radial_velocity(file_name)[radius_index] * \\\n                    simulation.rho(file_name)[radius_index]))\n    return -u.convert_to_solar_masses(",
        "detail": "AeViz.utils.masses_energies_utils",
        "documentation": {}
    },
    {
        "label": "u",
        "kind": 5,
        "importPath": "AeViz.utils.masses_energies_utils",
        "description": "AeViz.utils.masses_energies_utils",
        "peekOfCode": "u = units()\ndef innercore_mass_energy(simulation, file_name, innercore_radius, gcells, dV):\n    \"\"\"\n    Calculates the mass, kinetic, magnetic, rotational, gravitational\n    and total energy and T/|W| of the inner core for one timestep.\n    \"\"\"\n    if simulation.dim == 1:\n        mask = (simulation.cell.radius(simulation.ghost) <= \\\n            innercore_radius)\n    else:",
        "detail": "AeViz.utils.masses_energies_utils",
        "documentation": {}
    },
    {
        "label": "function_average",
        "kind": 2,
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "peekOfCode": "def function_average(qt, dim, av_type:Literal['Omega', 'theta', 'phi',\n                                              'radius', 'volume'], dV):\n    if dim == 1:\n        indices = {'r': 0, 't': None, 'p': None}\n    elif dim == 2:\n        indices = {'r': 1, 't': 0, 'p': None}\n    elif dim == 3:\n        indices = {'r': 2, 't': 1, 'p': 0}\n    if av_type == 'Omega':\n        if dim < 2:",
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "function_average_radii",
        "kind": 2,
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "peekOfCode": "def function_average_radii(qt, dim, dOmega):\n    if dim == 1:\n        return qt\n    else:\n        return np.nansum(qt * dOmega) / (4 * np.pi)\ndef IDL_derivative(x, y, xvariable: Literal['radius', 'theta', 'phi'] = 'radius'):\n    \"\"\"\n    Derivatie performed using three point Lagrangian interpolation, as in:\n    `https://www.l3harrisgeospatial.com/docs/deriv.html` \n    \"\"\"",
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "IDL_derivative",
        "kind": 2,
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "peekOfCode": "def IDL_derivative(x, y, xvariable: Literal['radius', 'theta', 'phi'] = 'radius'):\n    \"\"\"\n    Derivatie performed using three point Lagrangian interpolation, as in:\n    `https://www.l3harrisgeospatial.com/docs/deriv.html` \n    \"\"\"\n    if xvariable == 'theta':\n        y = np.moveaxis(y, -2, -1)\n    elif xvariable == 'phi':\n        y = np.moveaxis(y, -3, -1)\n    assert x.shape == y.shape or x.shape[0] == y[..., :].shape[-1], \\",
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "strfunction2D",
        "kind": 2,
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "peekOfCode": "def strfunction2D(b1, b2, ax, ay, az, lx, ly, lz, plane):\n    if plane == 'yz':\n        dF1 = 0\n        dF2 = 0\n        dl1 = 1\n        dl2 = 2\n    elif plane == 'xz':\n        dF1 =   b2 * az\n        dF2 = - b1 * ax\n        dl1 = ly",
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "strfct2D",
        "kind": 2,
        "importPath": "AeViz.utils.math_utils",
        "description": "AeViz.utils.math_utils",
        "peekOfCode": "def strfct2D(b, cell, ghost, plane):\n    \"\"\"\n    plane: 'yz', 'xz', 'xy'\n    cell: object cell\n    b magnetic field\n    \"\"\"\n    assert plane in ['yz', 'xz', 'xy'], \"plane must be one of: \\'yz\\', \"\\\n        \"\\'xz\\', \\'xy\\'\"\n    ax = cell.ax(ghost)\n    ay = cell.ay(ghost)",
        "detail": "AeViz.utils.math_utils",
        "documentation": {}
    },
    {
        "label": "get_indices_from_parfile",
        "kind": 2,
        "importPath": "AeViz.utils.parfiles",
        "description": "AeViz.utils.parfiles",
        "peekOfCode": "def get_indices_from_parfile(file_name, path_folder):\n    \"\"\"\n    Reads the simulation parfile and return a dictionary with the indices\n    of the hydro and thd quantities.\n    keywords: \n        first dictionary:\n            'hydro' : hydrodynamics quantities\n            'thd' : thermodynamics quantities\n        second dictionary:\n                                      HYDRO",
        "detail": "AeViz.utils.parfiles",
        "documentation": {}
    },
    {
        "label": "get_initial_parameters",
        "kind": 2,
        "importPath": "AeViz.utils.parfiles",
        "description": "AeViz.utils.parfiles",
        "peekOfCode": "def get_initial_parameters(path_folder):\n    initial_parameters = {\"omgadd\": 0.0,\n                          \"omgmult\": 0.0,\n                          \"bfact\": 0.0,\n                          \"btorfact\": 0.0,\n                          \"b0\": 0.0,\n                          \"bt\": 0.0\n                          }\n    start_pars = f90nml.read(os.path.join(path_folder, 'start.pars'))\n    if start_pars[\"PHYSSYST\"][\"RELATIVISTIC\"]:",
        "detail": "AeViz.utils.parfiles",
        "documentation": {}
    },
    {
        "label": "pltf",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def pltf():\n    platf = platform.system()\n    \"\"\"\n    The only platforms \"supported\" are Linux and Windows.\n    \"\"\"\n    if not platf in ['Windows', 'Linux']:\n        raise TypeError(\"Platform not suppoerted, sorry :)\")\n    return platf\ndef local_storage_folder(platf):\n    \"\"\"",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "local_storage_folder",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def local_storage_folder(platf):\n    \"\"\"\n    It sets up the local postprocessing folder for the simulations.\n    It also add a hidden folder which contains the windows mounting point, \n    if applicable, and the dictionary of the simulations paths.\n    \"\"\"\n    if platf == 'Windows':\n        storage_path = os.path.expanduser('~/Desktop/Aenus_simulation_postprocessing')\n    else:\n        storage_path = os.path.expanduser('~/Aenus_simulation_postprocessing')",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "simulation_local_storage_folder",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def simulation_local_storage_folder(platf, folder_name, dim):\n    \"\"\"\n    Some calculated quantities need are computationally expensive, therefore\n    they need to be stored in a convenient place (home folder in Linux or \n    Desktop in Windows).\n    \"\"\"\n    if platf == 'Windows':\n        storage_path = os.path.expanduser('~/Desktop/Aenus_simulation_postprocessing')\n    else:\n        storage_path = os.path.expanduser('~/Aenus_simulation_postprocessing')",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "windows_mount",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def windows_mount():\n    \"\"\"\n    Creates a dictionary in a file that specifies on which Windows partition\n    the server is mounted.\n    \"\"\"\n    message = \"We detected you are working on windows, but no\" + \\\n              \" mounted partition has been assigned.\"\n    print(message)\n    mount_path = input(\"Please insert the mount path (i.e. Z:): \")\n    with open(os.path.join(local_storage_folder(pltf()),",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "standardize_simulation_path",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def standardize_simulation_path(path):\n    \"\"\"\n    Returns standardized Linux path (i.e. path starting with '/')\n        in: path string\n    \"\"\"\n    if pltf() == 'Windows':\n        try:\n            from windows import windows_paths\n        except:\n            windows_mount()",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "read_path_file",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def read_path_file(path):\n    \"\"\"\n    Returns paths from a file in list format\n    in:\n        path: string, path to file\n    \"\"\"\n    if not os.path.exists(path):\n        return None\n    import numpy\n    return list(numpy.loadtxt(path, dtype=str))",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "list_of_paths",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def list_of_paths(files_path, single_paths):\n    \"\"\"\n    Returns list of all simulation paths to include\n    in:\n        files_path: list of strings, path to the file containing the simulations paths.\n        single_paths: list of the simulation paths to include.\n    \"\"\"\n    if single_paths:\n        path_list = single_paths\n    else:",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "remove_not_useful_folders",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def remove_not_useful_folders(dirs):\n    \"\"\"\n    Removes the folders containing the equations of state and initial models\n    from a list of directories\n    \"\"\"\n    dirs_to_remove = ['EOS', 'Initial_models', 'presn_models',\n                     'Stellarcollapse_EOS', 'CompOSE_EOS']\n    for dir in dirs_to_remove:\n        while dir in dirs:\n            dirs.remove(dir)",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "check_subpaths_for_simulations",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def check_subpaths_for_simulations(path, simDict, simulations):\n    \"\"\"\n    Recursively checks a folder and its subfolders to ensure the presence\n    of a simulation. Since every simulation contains a 'outp-hdf' folder\n    we use its presence as a criterion. If a simulation is fuond, it is stored\n    in the simulations dictionary.\n    \"\"\"\n    try:\n        dirs = remove_not_useful_folders(os.listdir(path))\n    except:",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "add_paths",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def add_paths(path_list):\n    \"\"\"\n    Creates or updates the simulations dictionary of all the simulations\n    found in a list of paths.\n    \"\"\"\n    simDict = get_paths_dictionary(True)\n    for p in path_list:\n        print('Path: ', p)\n        print('Checking...')\n        simDict, simulations = check_subpaths_for_simulations(p, simDict, [])",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "get_paths_dictionary",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def get_paths_dictionary(creating = False):\n    \"\"\"\n    Returns a simulations dictionary. Simulations are grouped in 1D, 2D and 3D.\n    \"\"\"\n    try:\n        sys.path.append(os.path.join(local_storage_folder(pltf()), '.utils'))\n        from simulations_dictionary import simulations_dictionary\n    except:\n        if creating:\n            simulations_dictionary = {'1D': {}, '2D': {}, '3D': {}}",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "save_paths_dictionary",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def save_paths_dictionary(simulations_dictionary):\n    with open(os.path.join(local_storage_folder(pltf()), '.utils', 'simulations_dictionary.py'), 'w') as f:\n        f.write('simulations_dictionary = ' + str(simulations_dictionary))\ndef return_real_path(folder, path, platform):\n    if platform not in ['Linux', 'Windows']:\n        raise TypeError(\"OS not supported. Supported platforms: Linux, Windows\")\n    if platform == 'Windows':\n        try:\n            sys.path.append(os.path.join(local_storage_folder(pltf()), '.utils'))\n            from windows import windows_paths",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "return_real_path",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def return_real_path(folder, path, platform):\n    if platform not in ['Linux', 'Windows']:\n        raise TypeError(\"OS not supported. Supported platforms: Linux, Windows\")\n    if platform == 'Windows':\n        try:\n            sys.path.append(os.path.join(local_storage_folder(pltf()), '.utils'))\n            from windows import windows_paths\n        except:\n            windows_mount()\n            sys.path.append(os.path.join(local_storage_folder(pltf()), '.utils'))",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "find_simulation",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def find_simulation(folder, platform, sim_path=None):\n    \"\"\"\n    Funcion that allows the user to find the path of a specific simulation.\n    Parameters:\n        folder: (string) the name of the simulation to find\n        platform: (string) the OS from which the script is running\n        sim_path: (string or None) the path of the chosen simulation\n    \"\"\"\n    if sim_path is not None:\n        path = os.path.join(sim_path, folder)",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "clear_folder",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def clear_folder(folder_path):\n    \"\"\"\n    Deletes all empty directories in a folder\n    \"\"\"\n    dirs = os.listdir(folder_path)\n    for folder in dirs:\n        path = os.path.join(folder_path, folder)\n        try:\n            if not os.listdir(path):\n                os.rmdir(path)",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "clear_simulation_folder",
        "kind": 2,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "def clear_simulation_folder(folder_list):\n    \"\"\"\n    Deletes all empty folders in a list of simulations.\n    \"\"\"\n    for folder in folder_list:\n        simulation_path = find_simulation(folder, pltf())\n        clear_folder(simulation_path)",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "dim_keys",
        "kind": 5,
        "importPath": "AeViz.utils.path_utils",
        "description": "AeViz.utils.path_utils",
        "peekOfCode": "dim_keys = {1: '1D', 2: '2D', 3: '3D'}\ndef pltf():\n    platf = platform.system()\n    \"\"\"\n    The only platforms \"supported\" are Linux and Windows.\n    \"\"\"\n    if not platf in ['Windows', 'Linux']:\n        raise TypeError(\"Platform not suppoerted, sorry :)\")\n    return platf\ndef local_storage_folder(platf):",
        "detail": "AeViz.utils.path_utils",
        "documentation": {}
    },
    {
        "label": "calculate_profile",
        "kind": 2,
        "importPath": "AeViz.utils.profiles",
        "description": "AeViz.utils.profiles",
        "peekOfCode": "def calculate_profile(simulation, profile):\n    \"\"\"\n    Returns the radial profile of the desired quantity. Quantity names\n    must be the same as the ones in the simulation class.\n    \"\"\"\n    if profile in ['BV_frequency', 'Rossby_number', 'Ye', 'temperature', 'rho',\n                   'entropy', 'convective_flux', 'gas_pressure']:\n        return read_profile(simulation, profile)\n    else:\n        return derive_profile(simulation, profile)",
        "detail": "AeViz.utils.profiles",
        "documentation": {}
    },
    {
        "label": "read_profile",
        "kind": 2,
        "importPath": "AeViz.utils.profiles",
        "description": "AeViz.utils.profiles",
        "peekOfCode": "def read_profile(simulation, profile):\n    \"\"\"\n    Reads the radial profile saved in the profiles.h5 file.\n    \"\"\"\n    if check_existence(simulation, 'profiles.h5'):\n        data = h5py.File(os.path.join(simulation.storage_path, 'profiles.h5'), 'r')\n        if len(data['time'][...])  == len(simulation.hdf_file_list):\n            t, pr = data['time'][...], data['profiles/' + profile][...]\n            data.close()\n            return t, simulation.cell.radius(simulation.ghost), pr",
        "detail": "AeViz.utils.profiles",
        "documentation": {}
    },
    {
        "label": "derive_profile",
        "kind": 2,
        "importPath": "AeViz.utils.profiles",
        "description": "AeViz.utils.profiles",
        "peekOfCode": "def derive_profile(simulation, profile):\n    \"\"\"\n    Calculates a single profile and returns it.\n    \"\"\"\n    qt = getattr(simulation, profile)\n    radius = len(simulation.cell.radius(simulation.ghost))\n    dOmega = simulation.cell.dOmega(simulation.ghost)\n    for (file, progress) in zip(simulation.hdf_file_list,\n                         range(len(simulation.hdf_file_list))):\n        try:",
        "detail": "AeViz.utils.profiles",
        "documentation": {}
    },
    {
        "label": "derive_profiles",
        "kind": 2,
        "importPath": "AeViz.utils.profiles",
        "description": "AeViz.utils.profiles",
        "peekOfCode": "def derive_profiles(simulation, data):\n    \"\"\"\n    Calculates and saves the pressure, temperature, Ye, entropy, \n    density, Rossby number, BV frequency, and convective flux radial\n    profiles in an hdf file.\n    \"\"\"\n    if data is None:\n        start_point = 0\n    else:\n        time = data['time'][...]",
        "detail": "AeViz.utils.profiles",
        "documentation": {}
    },
    {
        "label": "PNS_radius",
        "kind": 2,
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "peekOfCode": "def PNS_radius(simulation, file_name):\n    \"\"\"\n    Calculates the radius of the PNS for each timestep.\n    Employed method: radius at which the density drops below\n                     10^11 g/cm^3\n    \"\"\"\n    return simulation.cell.radius(simulation.ghost)[np.argmax(\n        simulation.rho(file_name) < 1e11, axis=-1)]\ndef innercore_radius(simulation, file_name):\n    \"\"\"",
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "innercore_radius",
        "kind": 2,
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "peekOfCode": "def innercore_radius(simulation, file_name):\n    \"\"\"\n    Calculates the radius of the inner core for each timestep. \n    The innercore is defined as the region in sonic contact with the\n    centre of the star. This corresponds to the region where the\n    sound speed is larger than the radial velocity.\n    Employed method: comparing the module of the radial with the\n                     sound speed.\n    \"\"\"\n    return simulation.cell.radius(simulation.ghost)[np.argmax(",
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "gain_radius",
        "kind": 2,
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "peekOfCode": "def gain_radius(simulation, file_name, PNS_radius):\n    \"\"\"\n    Calculates the radius of the gain region for each timestep. Gain\n    region is defined as the region where the neutrino heating becomes\n    larger than the cooling.\n    Employed method: finding the radius, outside the PNS where the \n                     neutrino energy depostion is larger than 0.\n    \"\"\"\n    radius = simulation.cell.radius(simulation.ghost)\n    neu_ene_dep = simulation.nu_heat(file_name)",
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "neutrino_sphere_radii",
        "kind": 2,
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "peekOfCode": "def neutrino_sphere_radii(simulation, file_name):\n    \"\"\"\n    Calculates the neutrino sphere for each neutrino flvaour radii at\n    each timestep.\n    Employed method: calculate k(r, θ, ϕ) as\n    k(r, θ, ϕ) = (∑_ω p^α(r, θ, ϕ, ω) κ_α(r, θ, ϕ, ω)) / \\\n        ∑_ω p^α(r, θ, ϕ, ω)\n    where p^α(r, θ, ϕ, ω) is the neutrino three-momentum of each \n    neutrino flavour,  ω is the neutrino energy and κ_α(r, θ, ϕ, ω) is\n    the neutrino opacity.",
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "PNS_nucleus",
        "kind": 2,
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "peekOfCode": "def PNS_nucleus(simulation, file_name):\n    \"\"\"\n    Calculates the radius of the PNS nucleus for each timestep.\n    Employed method: entropy jump at s=4kb from the inside out.\n    \"\"\"\n    radius = simulation.cell.radius(simulation.ghost)\n    R_30Km_index = np.argmax(radius >= 30e5)\n    s = simulation.entropy(file_name)[..., :R_30Km_index]\n    minYe = np.argmax(s >= 4, axis=-1)\n    return radius[minYe]",
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "shock_radius",
        "kind": 2,
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "peekOfCode": "def shock_radius(simulation, file_name):\n    \"\"\"\n    Calculates the shock radius for each timestep.\n    Employed method: first jump in pressure and radial velocity after\n                    the bounce, considered from infinite to the centre.\n    \"\"\"\n    if simulation.time(file_name, True) <= 0:\n        if simulation.dim == 1:\n            return np.array([0])\n        return np.zeros(simulation.cell.dVolume_integration(",
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "shock_radius_1D",
        "kind": 2,
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "peekOfCode": "def shock_radius_1D(simulation, file_name):\n    dP = IDL_derivative(simulation.cell.radius(simulation.ghost),\n                        simulation.gas_pressure(file_name)) * \\\n                            simulation.cell.radius(simulation.ghost) / \\\n                            simulation.gas_pressure(file_name)\n    dvr = IDL_derivative(simulation.cell.radius(simulation.ghost),\n                         simulation.radial_velocity(file_name)) * \\\n                             simulation.cell.radius(simulation.ghost) / \\\n                             np.abs(simulation.radial_velocity(file_name))\n    for ir in reversed(range(len(dP) - 1)):",
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "shock_radius_2D",
        "kind": 2,
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "peekOfCode": "def shock_radius_2D(simulation, file_name):\n    dP = IDL_derivative(simulation.cell.radius(simulation.ghost),\n                        simulation.gas_pressure(file_name)) * \\\n                            simulation.cell.radius(simulation.ghost) / \\\n                            simulation.gas_pressure(file_name)\n    dvr = IDL_derivative(simulation.cell.radius(simulation.ghost),\n                         simulation.radial_velocity(file_name)) * \\\n                             simulation.cell.radius(simulation.ghost) / \\\n                             np.abs(simulation.radial_velocity(file_name))\n    shock_r = np.empty(dP.shape[0])",
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "shock_radius_3D",
        "kind": 2,
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "peekOfCode": "def shock_radius_3D(simulation, file_name):\n    dP = IDL_derivative(simulation.cell.radius(simulation.ghost),\n                        simulation.gas_pressure(file_name)) * \\\n                            simulation.cell.radius(simulation.ghost) / \\\n                            simulation.gas_pressure(file_name)\n    dvr = IDL_derivative(simulation.cell.radius(simulation.ghost),\n                         simulation.radial_velocity(file_name)) * \\\n                             simulation.cell.radius(simulation.ghost) / \\\n                             np.abs(simulation.radial_velocity(file_name))\n    shock_r = np.empty((dP.shape[0], dP.shape[1]))",
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "hampel_filter",
        "kind": 2,
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "peekOfCode": "def hampel_filter(shock_radius, sigma=3):\n    \"\"\"\n    Applies a hampel filter to the shock radius.\n    \"\"\"\n    assert shock_radius.size > 1 and shock_radius.ndim >= 1, \"Expected 1 or 2 \\\n            dimensional array, with at least 2 elements.\"\n    print(\"here\")\n    for i in range(10):\n        rmedian = np.nanmedian(shock_radius)\n        diff = np.abs(shock_radius - rmedian)",
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "interpol_1D",
        "kind": 2,
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "peekOfCode": "def interpol_1D(shock_radius, theta):\n    mask = np.isnan(shock_radius)\n    if mask.sum() == 0:\n        return shock_radius\n    shock_radius[mask] = np.interp(theta[mask], theta[~mask],\n                                   shock_radius[~mask])\n    return shock_radius\ndef interpol_2D(shock_radius, theta, phi):\n    mask = np.isnan(shock_radius)\n    if mask.sum() == 0:",
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "interpol_2D",
        "kind": 2,
        "importPath": "AeViz.utils.radii_utils",
        "description": "AeViz.utils.radii_utils",
        "peekOfCode": "def interpol_2D(shock_radius, theta, phi):\n    mask = np.isnan(shock_radius)\n    if mask.sum() == 0:\n        return shock_radius\n    Phi, Theta = np.meshgrid(phi, theta)\n    shock_radius = np.ma.masked_invalid(shock_radius)\n    shock_radius[shock_radius.mask] = \\\n        griddata((Phi[~shock_radius.mask], Theta[~shock_radius.mask]),\n                 shock_radius.ravel(), (Phi[shock_radius.mask], \n                                        Theta[shock_radius.mask]),",
        "detail": "AeViz.utils.radii_utils",
        "documentation": {}
    },
    {
        "label": "AssociatedLegendrePolynomials",
        "kind": 6,
        "importPath": "AeViz.utils.spherical_harmonics",
        "description": "AeViz.utils.spherical_harmonics",
        "peekOfCode": "class AssociatedLegendrePolynomials:\n    def __init__(self):\n        pass\n    def change_m_sign(self, m, l, P):\n        \"\"\"\n        Renormaqlizes the polynomial order from m to -m, using the\n        relation:\n        P^m_l(x) = (-1)^m (l-m)!/(l+m)! P^-m_l(x)\n        Takes as input:\n            l: original degree of the polynomial",
        "detail": "AeViz.utils.spherical_harmonics",
        "documentation": {}
    },
    {
        "label": "SphericalHarmonics",
        "kind": 6,
        "importPath": "AeViz.utils.spherical_harmonics",
        "description": "AeViz.utils.spherical_harmonics",
        "peekOfCode": "class SphericalHarmonics(AssociatedLegendrePolynomials):\n    def __init__(self):\n        pass\n    def Ylm(self, m, l, theta, phi):\n        \"\"\"\n        Calculates the spherical harmonic of order m and degree l.\n        Uses the definition:\n        Y^m_l(theta, phi) = (-)^m (2l+1)/(4π) (l-m)!/(l+m)! P^m_l(\n            cos(theta)) exp(i m phi)\n        Takes as input:",
        "detail": "AeViz.utils.spherical_harmonics",
        "documentation": {}
    },
    {
        "label": "progressBar",
        "kind": 2,
        "importPath": "AeViz.utils.utils",
        "description": "AeViz.utils.utils",
        "peekOfCode": "def progressBar(count_value, total, suffix=''):\n    bar_length = 100\n    filled_up_Length = int(round(bar_length * count_value / float(total)))\n    percentage = round(100.0 * count_value/float(total),1)\n    bar = '#' * filled_up_Length + '-' * (bar_length - filled_up_Length)\n    sys.stdout.write('[%s] %s%s ...%s\\r' %(bar, percentage, '%', suffix))\n    sys.stdout.flush()\ndef check_existence(simulation, file_name):\n    \"\"\"\n    Check if the radius calculation has already been performed or at",
        "detail": "AeViz.utils.utils",
        "documentation": {}
    },
    {
        "label": "check_existence",
        "kind": 2,
        "importPath": "AeViz.utils.utils",
        "description": "AeViz.utils.utils",
        "peekOfCode": "def check_existence(simulation, file_name):\n    \"\"\"\n    Check if the radius calculation has already been performed or at\n    least partially performed.\n    \"\"\"\n    if os.path.exists(os.path.join(simulation.storage_path, \n                                       file_name)):\n        return True\n    else:\n        return False",
        "detail": "AeViz.utils.utils",
        "documentation": {}
    },
    {
        "label": "fig",
        "kind": 5,
        "importPath": "prova",
        "description": "prova",
        "peekOfCode": "fig = plt.figure(figsize=(10, 10))\naxs = fig.subplot_mosaic()\nfig.subplots_adjust(wspace=0.0)\naxs[\"B\"].sharex(axs[\"A\"])\naxs[\"B\"].sharey(axs[\"A\"])\naxs[\"A\"].tick_params(top=False, labeltop=False,\n                                          bottom=True, labelbottom=True,\n                                          left=True, labelleft=True,\n                                          right=False, labelright=False)\naxs[\"B\"].tick_params(top=False, labeltop=False,",
        "detail": "prova",
        "documentation": {}
    },
    {
        "label": "axs",
        "kind": 5,
        "importPath": "prova",
        "description": "prova",
        "peekOfCode": "axs = fig.subplot_mosaic()\nfig.subplots_adjust(wspace=0.0)\naxs[\"B\"].sharex(axs[\"A\"])\naxs[\"B\"].sharey(axs[\"A\"])\naxs[\"A\"].tick_params(top=False, labeltop=False,\n                                          bottom=True, labelbottom=True,\n                                          left=True, labelleft=True,\n                                          right=False, labelright=False)\naxs[\"B\"].tick_params(top=False, labeltop=False,\n                                          bottom=True, labelbottom=True,",
        "detail": "prova",
        "documentation": {}
    },
    {
        "label": "Plot",
        "kind": 5,
        "importPath": "prova",
        "description": "prova",
        "peekOfCode": "Plot = Plotting()\nPlot.Load('/almacen/marco/Simulations/sn2d/s16.5-SW14/s16.5-SFHo-1.0omg-5e+08-1e+09B/outp-hdf/h00045000.h5')\nPlot.plot1D('PGAS', 'radius', 32, None)\nPlot.plot1D('ENTR', 'radius', 32, None)\n#Plot.plot2DwithPar('V')\ninput()\n\"\"\"\n#sim = Simulation('s16.5-SFHo-1.0omg-5e+08-1e+09B-timestep0.1ms', '/almacen/marco/Simulations/sn2d/s16.5-SW14/')\nsim = Simulation('A26-1', '/home/marco/Escritorio/Simulations/martin/sn3d/Bonn/')\n\"\"\"",
        "detail": "prova",
        "documentation": {}
    },
    {
        "label": "#sim",
        "kind": 5,
        "importPath": "prova",
        "description": "prova",
        "peekOfCode": "#sim = Simulation('s16.5-SFHo-1.0omg-5e+08-1e+09B-timestep0.1ms', '/almacen/marco/Simulations/sn2d/s16.5-SW14/')\nsim = Simulation('A26-1', '/home/marco/Escritorio/Simulations/martin/sn3d/Bonn/')\n\"\"\"\nradius = sim.cell.radius(sim.ghost)\nP = sim.gas_pressure('h00045000.h5')\nvx = sim.radial_velocity('h00045000.h5')\nshock = shock_radius(sim, 'h00045000.h5')\nprint(np.any(shock==np.nan))\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\naxs[0].plot(sim.cell.theta(sim.ghost), shock)",
        "detail": "prova",
        "documentation": {}
    },
    {
        "label": "sim",
        "kind": 5,
        "importPath": "prova",
        "description": "prova",
        "peekOfCode": "sim = Simulation('A26-1', '/home/marco/Escritorio/Simulations/martin/sn3d/Bonn/')\n\"\"\"\nradius = sim.cell.radius(sim.ghost)\nP = sim.gas_pressure('h00045000.h5')\nvx = sim.radial_velocity('h00045000.h5')\nshock = shock_radius(sim, 'h00045000.h5')\nprint(np.any(shock==np.nan))\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\naxs[0].plot(sim.cell.theta(sim.ghost), shock)\naxs[0].plot(sim.cell.radius(sim.ghost), P[32,...])",
        "detail": "prova",
        "documentation": {}
    },
    {
        "label": "radius",
        "kind": 5,
        "importPath": "prova",
        "description": "prova",
        "peekOfCode": "radius = sim.cell.radius(sim.ghost)\nP = sim.gas_pressure('h00045000.h5')\nvx = sim.radial_velocity('h00045000.h5')\nshock = shock_radius(sim, 'h00045000.h5')\nprint(np.any(shock==np.nan))\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\naxs[0].plot(sim.cell.theta(sim.ghost), shock)\naxs[0].plot(sim.cell.radius(sim.ghost), P[32,...])\naxs[0].set_xscale('log')\naxs[0].set_yscale('log')",
        "detail": "prova",
        "documentation": {}
    },
    {
        "label": "P",
        "kind": 5,
        "importPath": "prova",
        "description": "prova",
        "peekOfCode": "P = sim.gas_pressure('h00045000.h5')\nvx = sim.radial_velocity('h00045000.h5')\nshock = shock_radius(sim, 'h00045000.h5')\nprint(np.any(shock==np.nan))\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\naxs[0].plot(sim.cell.theta(sim.ghost), shock)\naxs[0].plot(sim.cell.radius(sim.ghost), P[32,...])\naxs[0].set_xscale('log')\naxs[0].set_yscale('log')\naxs[0].axvline(shock[32], color='k')",
        "detail": "prova",
        "documentation": {}
    },
    {
        "label": "vx",
        "kind": 5,
        "importPath": "prova",
        "description": "prova",
        "peekOfCode": "vx = sim.radial_velocity('h00045000.h5')\nshock = shock_radius(sim, 'h00045000.h5')\nprint(np.any(shock==np.nan))\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\naxs[0].plot(sim.cell.theta(sim.ghost), shock)\naxs[0].plot(sim.cell.radius(sim.ghost), P[32,...])\naxs[0].set_xscale('log')\naxs[0].set_yscale('log')\naxs[0].axvline(shock[32], color='k')\nax1 =axs[0].twinx()",
        "detail": "prova",
        "documentation": {}
    },
    {
        "label": "shock",
        "kind": 5,
        "importPath": "prova",
        "description": "prova",
        "peekOfCode": "shock = shock_radius(sim, 'h00045000.h5')\nprint(np.any(shock==np.nan))\nfig, axs = plt.subplots(1, 2, figsize=(10, 5))\naxs[0].plot(sim.cell.theta(sim.ghost), shock)\naxs[0].plot(sim.cell.radius(sim.ghost), P[32,...])\naxs[0].set_xscale('log')\naxs[0].set_yscale('log')\naxs[0].axvline(shock[32], color='k')\nax1 =axs[0].twinx()\nax1.plot(sim.cell.radius(sim.ghost), IDL_derivative(radius, P[32,:])/P[32, :] * radius, color='b')",
        "detail": "prova",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "prova",
        "description": "prova",
        "peekOfCode": "data = sim.AE220()\nfig, axs = plt.subplots(3, 1, sharex=True)\naxs[0].plot(data[1], data[3])\naxs[1].plot(data[1], data[4])\naxs[2].plot(data[1], data[5])\nplt.show()\n#print(time.shape, radius.shape, pr.shape)\n\"\"\"",
        "detail": "prova",
        "documentation": {}
    }
]