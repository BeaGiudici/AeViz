#!/usr/bin/env python

########################################################################
#
# remap_Aenus
# Script to remap Aenus/ALCAR simulation files to a new grid
# with more cells in the radial direction.
# In the future it would be nice to have a more general remapping
# script, but for now this is enough.
#
# I know what you are thinking: why didn't you use the built-in 
# AeViz structure for the data? Because I have to recreate a new .h5
# file with the exact same structure as the original one, and it is
# way easier to do it this way (that's what I thought...).
#
# Author: Beatrice Giudici (beatrice.giudici@uv.es)
#
########################################################################


import h5py
import numpy as np
import argparse
from AeViz.simulation.simulation import Simulation
import os
import f90nml

def interpolate(nx, ny, nz, sim_grid, prog_grid, prog_values, sim_value=None, n0=0):
  """Interpolate simulation grid values to progenitor grid."""
  new_values = np.empty((nz, ny, nx))
  if sim_value is not None:
    new_values[:,:,:n0] = sim_value[:,:,:n0]
  for iz in range(nz):
    for iy in range(ny):
      for ix in range(n0, nx):
        for ip in range(prog_grid.shape[0]-1):
          if (sim_grid[ix] >= prog_grid[ip]) and (sim_grid[ix] < prog_grid[ip+1]):
            # Linear interpolation
            x0 = prog_grid[ip]
            x1 = prog_grid[ip+1]
            y0 = prog_values[ip]
            y1 = prog_values[ip+1]
            slope = (y1 - y0) / (x1 - x0)
            new_values[iz, iy, ix] = y0 + slope * (sim_grid[ix] - x0)
            break
  return new_values

parser = argparse.ArgumentParser()
parser.add_argument('--sim-name', required=True, type=str, \
                    help ='Name of the simulation')
parser.add_argument('--sim-path', type=str, default=None, required=False,
                    help="Path of the simulation.")
parser.add_argument('--file', required=True, type=str, \
            help='File name to be remapped (with .h5 extension , please)')
'''
parser.add_argument('--new-xmin', required=False, type=float, \
                    help='New value for XMIN')
parser.add_argument('--new-xmax', required=False, type=float, \
                    help='New value for XMAX')
parser.add_argument('--new-nx', required=False, type=int, \
                    help='New value for number of points in x direction')
parser.add_argument('--new-ymin', required=False, type=float, \
                    help='New value for YMIN')
parser.add_argument('--new-ymax', required=False, type=float, \
                    help='New value for YMAX')
parser.add_argument('--new-ny', required=False, type=int, \
                    help='New value for number of points in y direction')  
parser.add_argument('--new-zmin', required=False, type=float, \
                    help='New value for ZMIN')
parser.add_argument('--new-zmax', required=False, type=float, \
                    help='New value for ZMAX') 
parser.add_argument('--new-nz', required=False, type=int, \
                    help='New value for number of points in z direction')
'''
parser.add_argument('--ncells', required=False, type=int, \
                    help='Number of cells to add')
parser.add_argument('--prog-location', required=True, type=str, \
                    help='Path to the progenitor files')
args = parser.parse_args()
filename = args.file
ncells = args.ncells

# I know my chickens...
if filename[-3:] != '.h5':
  filename += '.h5'

m = Simulation(args.sim_name, args.sim_path)
simdir = m.path
outpath = os.path.join(m.storage_path, 'remap_files')

print(f'Files will be saved in {outpath}')

if not os.path.isdir(outpath):
  os.mkdir(outpath)

print('Not remapping neutrino energies. Copying "grid.e.dat" file...')
os.system(f'cp {os.path.join(simdir, 'grid', 'grid.e.dat')} {os.path.join(outpath, 'grid.e.dat')}')

print('Not remapping y grid. Copying "grid.y.dat" file...')
n, yl, y, yr = np.genfromtxt(os.path.join(simdir, 'grid', 'grid.y.dat'), unpack=True)
ny = y.shape[0]
os.system(f'cp {os.path.join(simdir, 'grid', 'grid.y.dat')} {os.path.join(outpath, 'grid.y.dat')}')

print('Not remapping z grid. Copying "grid.z.dat" file...')
n, zl, z, zr = np.genfromtxt(os.path.join(simdir, 'grid', 'grid.z.dat'), unpack=True)
try:
  nz = len(z)
except:
  nz = 1
os.system(f'cp {os.path.join(simdir, 'grid', 'grid.z.dat')} {os.path.join(outpath, 'grid.z.dat')}')

# Remap the grid
print('Remapping the x grid...')
n, xl, x, xr = np.genfromtxt(os.path.join(simdir, 'grid', 'grid.x.dat'), unpack=True)
n0 = n.shape[0]
alpha = (xr[-1] - xl[-1]) / (xr[-2] - xl[-2])
for i in range(n0, n0 + ncells):
  dx_new = (xr[i-1] - xl[i-1]) * alpha
  xl = np.append(xl, xr[i-1])
  xr = np.append(xr, xl[i] + dx_new)
  x = np.append(x, 0.5 * (xl[i] + xr[i]))
  n = np.append(n, i)

nx = x.shape[0]

np.savetxt(os.path.join(outpath, 'grid.x.dat'), np.array([n, xl, x, xr]).T, \
           fmt=['%d', '%.12e', '%.12e', '%.12e'])

# (M)HD remapping script
f = h5py.File(os.path.join(simdir, 'outp-hdf', filename), 'r')
fnew = h5py.File(os.path.join(outpath, filename), 'w')
prog = np.genfromtxt(os.path.join(args.prog_location, 'star.dat'), \
                      unpack=True)
star_n, star_xl, star_xc, star_xr = np.genfromtxt(os.path.join(args.prog_location, \
                                       'initial_model.x.dat'), unpack=True)

# General grid, parameters and indices that does not need fancy remapping
grid_mask = (star_xc >= x[n0]) & (star_xc <= x[-1])

# If magnetic field is needed
if 'mag_CT' in f.keys():
  print('Intorpolating magnetic field...')
  # Compute the vector potential in the progenitor grid
  Bpol = prog[10]
  Btor = prog[9]
  fr = 0.5 * Bpol * star_xc
  fr_interp_m = interpolate(nx, ny, nz, xl, star_xl, fr, n0=0)
  fr_interp_p = interpolate(nx, ny, nz, xr, star_xr, fr, n0=0)
  Bz = interpolate(nx, ny, nz, x, star_xc, Btor, n0=0)

  # Face centered grid points in theta and phi directions
  Bz_CT = np.zeros_like(Bz)
  Bz_CT[1:-1, :, :] = 0.5 * (Bz[1:-1, :, :] + Bz[:-2, :, :])
  if nz > 1:
    Bz_CT[0, :, :] = Bz_CT[1, :, :]
    Bz_CT[-1, :, :] = Bz_CT[-2, :, :]

  # Face centered magnetic field components from vector potential
  A1 = np.sin(yr[None,:,None]) * fr_interp_p * np.sin(yr[None,:,None])
  A2 = np.sin(yl[None,:,None]) * fr_interp_p * np.sin(yl[None,:,None])
  Bx_CT = (1. / (xr[None, None, :] * np.sin(y[None,:,None]))) * \
    ( (A1 - A2) / (yr[None,:,None] - yl[None,:,None]))
  A1 = fr_interp_p * np.sin(yr[None,:,None]) * xr[None, None, :]
  A2 = fr_interp_m * np.sin(yr[None,:,None]) * xl[None, None, :]
  By_CT = (-1. / x[None, None, :]) * ( (A1 - A2) / \
                                  (xr[None, None, :] - xl[None, None, :]) )

  # Cell centered magnetic field components
  By = np.zeros_like(By_CT)
  Bx = np.zeros_like(Bx_CT)
  By[:, 1:-1, :] = 0.5 * (By_CT[:, 1:-1, :] + By_CT[:, :-2, :])
  By[:, 0,  :] = By[:, 1,  :]
  By[:, -1, :] = By[:, -2, :]
  Bx[:, :, 1:-1] = 0.5 * (Bx_CT[:, :, 1:-1] + Bx_CT[:, :, :-2])
  Bx[:, :, 0] = Bx[:, :, 1]
  Bx[:, :, -1] = Bx[:, :, -2]

# Get parfile
parfile = f90nml.read(os.path.join(simdir, 'pars', 'start.pars'))

for g in f.keys():
  print(f'Remapping {g}...')
  fnew.require_group(g)
  if g in ['Indices', 'Parameters']:
    for d in f[g].keys():
      fnew[g].create_dataset(d, data=f[g][d][...])
  
  # Grid
  if g in ['X', 'Y', 'Z']:
    _, l, c, r = np.genfromtxt(os.path.join(outpath, f'grid.{g.lower()}.dat'), unpack=True)
    fnew[g].create_dataset('znl', data=l)
    fnew[g].create_dataset('znr', data=r)
    fnew[g].create_dataset('znc', data=c)
    fnew[g].create_dataset(f'ipl{g.lower()}', data=f[g][f'ipl{g.lower()}'][...])
    fnew[g].create_dataset(f'itl{g.lower()}', data=f[g][f'itl{g.lower()}'][...])
    fnew[g].create_dataset(f'ipr{g.lower()}', data=f[g][f'ipr{g.lower()}'][...])
    fnew[g].create_dataset(f'itr{g.lower()}', data=f[g][f'itr{g.lower()}'][...])

  # If full neutrino is used
  if g == 'egrid':
    for d in f['egrid'].keys():
      fnew['egrid'].create_dataset(d, data=f['egrid'][d][...])

  if g == 'neutrino':
    en = np.concatenate((f[g]['e'][...], np.zeros((nz, ny, ncells, \
          f[g]['e'].shape[3], f[g]['e'].shape[4], f[g]['e'].shape[5]))), axis=2)
    fnew[g].create_dataset('e', data=en)
    oen = np.concatenate((f[g]['oe'][...], np.zeros((nz, ny, ncells, \
          f[g]['oe'].shape[3], f[g]['oe'].shape[4], f[g]['oe'].shape[5]))), axis=2)
    fnew[g].create_dataset('oe', data=oen)
  
  if g == 'neutrinogrey':
    ene = np.concatenate((f[g]['egrey'][...], np.zeros((nz, ny, ncells, \
                    f[g]['egrey'].shape[3], f[g]['egrey'].shape[4]))), axis=2)
    fnew[g].create_dataset('egrey', data=ene)

  # Gravitational waves
  if g == 'GW':
    fnew[g].create_dataset('Q20_mom', data=f[g]['Q20_mom'][...])
    fnew[g].create_dataset('Q20_rho', data=f[g]['Q20_rho'][...])
    Q20_mom_r = np.append(f[g]['Q20_mom_r'][...], np.zeros(ncells))
    Q20_rho_r = np.append(f[g]['Q20_rho_r'][...], np.zeros(ncells))
    fnew[g].create_dataset('Q20_mom_r', data=Q20_mom_r)
    fnew[g].create_dataset('Q20_rho_r', data=Q20_rho_r)

  # Magnetic field
  if g == 'divb':
    # Divergence-free condition: divb always = 0 in the new cells
    divb = np.concatenate((f[g]['data'][...], np.zeros((nz, ny, ncells))), axis=2)
    fnew[g].create_dataset('data', data=divb)

  if g == 'mag_CT':
    #print('WARNING! Please recheck the computations, I might have made mistakes')
    mag_CT_new = np.zeros((nz, ny, nx, 3))
    mag_CT_new[:,:, :n0, 0] = f[g]['data'][:, :, :, 0]
    mag_CT_new[:,:, :n0, 1] = f[g]['data'][:, :, :, 1]
    mag_CT_new[:,:, :n0, 2] = f[g]['data'][:, :, :, 2]
    mag_CT_new[:, :, n0:, 0] = Bx_CT[:, :, n0:]
    mag_CT_new[:, :, n0:, 1] = By_CT[:, :, n0:]
    mag_CT_new[:, :, n0:, 2] = Bz_CT[:, :, n0:]
    fnew[g].create_dataset('data', data=mag_CT_new)

  if g == 'mag_vol':
    #print('WARNING! Please recheck the computations, I might have made mistakes')
    mag_vol_new = np.zeros((nz, ny, nx, 3))
    mag_vol_new[:,:, :n0, 0] = f[g]['data'][:, :, :, 0]
    mag_vol_new[:,:, :n0, 1] = f[g]['data'][:, :, :, 1]
    mag_vol_new[:,:, :n0, 2] = f[g]['data'][:, :, :, 2]
    mag_vol_new[:, :, n0:, 0] = Bx[:, :, n0:]
    mag_vol_new[:, :, n0:, 1] = By[:, :, n0:]
    mag_vol_new[:, :, n0:, 2] = Bz[:, :, n0:]
    fnew[g].create_dataset('data', data=mag_vol_new)

  # Gravitational potential
  if g == 'gravpot':
    gravpot = np.concatenate((f[g]['data'][...], np.zeros((nz, ny, ncells))), axis=2)

  # Hydrodynamics variables
  if g == 'hydro':
    hd = f[g]['data'][...]
    hd_new = np.zeros((nz, ny, nx, hd.shape[3]))
    hd_new[:, :, :n0, :] = hd[:, :, :n0, :]
    if 'I_RH' in parfile["IINDICES"] and parfile["IINDICES"]["I_RH"] > -1:
      rho = hd[:, :, :, parfile["IINDICES"]["I_RH"] - 1]
      hd_new[:, :, :, parfile["IINDICES"]["I_RH"] - 1] = \
          interpolate(nx, ny, nz, x, star_xc, prog[0], sim_value=rho, n0=n0)
    if 'I_EN' in parfile["IINDICES"] and parfile["IINDICES"]["I_EN"] > -1:
      eint = hd[:, :, :, parfile["IINDICES"]["I_EN"] - 1]
      hd_new[:, :, :, parfile["IINDICES"]["I_EN"] - 1] = \
          interpolate(nx, ny, nz, x, star_xc, prog[4], sim_value=eint, n0=n0)
    if 'I_VX' in parfile["IINDICES"] and parfile["IINDICES"]["I_VX"] > -1:
      velx = hd[:, :, :, parfile["IINDICES"]["I_VX"] - 1]
      hd_new[:, :, :, parfile["IINDICES"]["I_VX"] - 1] = \
          interpolate(nx, ny, nz, x, star_xc, prog[7] * prog[0], sim_value=velx, n0=n0)
    if 'I_VY' in parfile["IINDICES"] and parfile["IINDICES"]["I_VY"] > -1:
      vely = hd[:, :, :, parfile["IINDICES"]["I_VY"] - 1]
      hd_new[:, :, :, parfile["IINDICES"]["I_VY"] - 1] = \
          interpolate(nx, ny, nz, x, star_xc, prog[8] * star_xc * prog[0], \
                      sim_value=vely, n0=n0)
    if 'I_VZ' in parfile["IINDICES"] and parfile["IINDICES"]["I_VZ"] > -1:
      velz = hd[:, :, :, parfile["IINDICES"]["I_VZ"] - 1]
      hd_new[:, :, :, parfile["IINDICES"]["I_VZ"] - 1] = \
          np.concatenate((velz, np.zeros((nz, ny, ncells))), axis=2)
    if 'I_YE' in parfile["IINDICES"] and parfile["IINDICES"]["I_YE"] > -1:
      ye = hd[:, :, :, parfile["IINDICES"]["I_YE"] - 1]
      hd_new[:, :, :, parfile["IINDICES"]["I_YE"] - 1] = \
          interpolate(nx, ny, nz, x, star_xc, prog[2], sim_value=ye, n0=n0)

    fnew[g].create_dataset('data', data=hd_new)


  # Thermodynamics remapping
  if g == 'thd':
    fnew[g].create_dataset('variables', data=f[g]['variables'][...])
    fnew[g].create_dataset('thddim', data=f[g]['thddim'][...])

    # Let's go one-by-one for the remapping
    data_new = np.empty((nz, ny, nx, f[g]['thddim'][()][0]))

    # DENS
    if 'i_dens' in f[g].keys():
      i = f[g]['i_dens'][()][0]
      fnew[g].create_dataset('i_dens', data=i)
      dens = f[g]['data'][:, :, :, i - 1]
      data_new[..., i-1] = np.concatenate((dens, np.ones((nz, ny, ncells))), axis=2)
    
    # Pressure
    if 'i_pgas' in f[g].keys():
      i = f[g]['i_pgas'][()][0]
      fnew[g].create_dataset('i_pgas', data=i)
      pgas = f[g]['data'][..., i - 1]
      data_new[..., i - 1] = interpolate(nx, ny, nz, x, star_xc, prog[3], \
                                         sim_value=pgas, n0=n0)
    
    # Temperature
    if 'i_tmpr' in f[g].keys():
      i = f[g]['i_tmpr'][()][0]
      fnew[g].create_dataset('i_tmpr', data=i)
      tmpr = f[g]['data'][..., i-1]
      data_new[..., i-1] = interpolate(nx, ny, nz, x, star_xc, prog[1], \
                                       sim_value=tmpr, n0=n0)

    # Internal energy
    if 'i_eint' in f[g].keys():
      i = f[g]['i_eint'][()][0]
      fnew[g].create_dataset('i_eint', data=i)
      eint = f[g]['data'][..., i-1]
      data_new[..., i-1] = interpolate(nx, ny, nz, x, star_xc, prog[2], \
                                       sim_value=eint, n0=n0)
    
    # Radial velocity
    if 'i_velx' in f[g].keys():
      i = f[g]['i_velx'][()][0]
      fnew[g].create_dataset('i_velx', data=i)
      velx = f[g]['data'][..., i-1]
      data_new[..., i-1] = interpolate(nx, ny, nz, x, star_xc, prog[7], \
                                       sim_value=velx, n0=n0)
      
    # Theta velocity
    if 'i_vely' in f[g].keys():
      i = f[g]['i_vely'][()][0]
      fnew[g].create_dataset('i_vely', data=i)
      vely = f[g]['data'][..., i-1]
      data_new[..., i-1] = interpolate(nx, ny, nz, x, star_xc, \
                                      prog[8] * star_xc, sim_value=vely, n0=n0)

    # Phi velocity
    if 'i_velz' in f[g].keys():
      i = f[g]['i_velz'][()][0]
      fnew[g].create_dataset('i_velz', data=i)
      velz = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((velz, np.zeros((nz, ny, ncells))), axis=2)
      
    # Lorentz factor
    if 'i_Lrtz' in f[g].keys():
      i = f[g]['i_Lrtz'][()][0]
      fnew[g].create_dataset('i_Lrtz', data=i)
      Lrtz = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((Lrtz, np.ones((nz, ny, ncells))), axis=2)

    # Entropy
    if 'i_entr' in f[g].keys():
      i = f[g]['i_entr'][()][0]
      fnew[g].create_dataset('i_entr', data=i)
      entr = f[g]['data'][..., i-1]
      data_new[..., i-1] = interpolate(nx, ny, nz, x, star_xc, prog[4], \
                                       sim_value=entr, n0=n0)
    
    # Enthalpy
    if 'i_enth' in f[g].keys():
      i = f[g]['i_enth'][()][0]
      fnew[g].create_dataset('i_enth', data=i)
      enth = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((enth, np.ones((nz, ny, ncells))), axis=2)

    # EOS gamma
    if 'i_gamm' in f[g].keys():
      i = f[g]['i_gamm'][()][0]
      fnew[g].create_dataset('i_gamm', data=i)
      gamm = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((gamm, np.ones((nz, ny, ncells)) * 4./3.), axis=2)

    # eoserr
    if 'i_eoserr' in f[g].keys():
      i = f[g]['i_eoserr'][()][0]
      fnew[g].create_dataset('i_eoserr', data=i)
      eoserr = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((eoserr, np.zeros((nz, ny, ncells))), axis=2)

    # eoscls
    if 'i_eoscls' in f[g].keys():
      i = f[g]['i_eoscls'][()][0]
      fnew[g].create_dataset('i_eoscls', data=i)
      eoscls = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((eoscls, np.zeros((nz, ny, ncells))), axis=2)

    # Chemical potential
    if 'i_cpot' in f[g].keys():
      i = f[g]['i_cpot'][()][0]
      fnew[g].create_dataset('i_cpot', data=i)
      cpot = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((cpot, np.zeros((nz, ny, ncells))), axis=2)

    for ic in range(5,8):
      if 'i_cpot-%03d' % ic in f[g].keys():
        i = f[g]['i_cpot-%03d' % ic][()][0]
        fnew[g].create_dataset('i_cpot-%03d' % ic, data=i)
        cpot = f[g]['data'][..., i-1]
        data_new[..., i-1] = np.concatenate((cpot, np.zeros((nz, ny, ncells))), axis=2)

    # comp
    if 'i_comp' in f[g].keys():
      i = f[g]['i_comp'][()][0]
      fnew[g].create_dataset('i_comp', data=i)
      comp = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((comp, np.zeros((nz, ny, ncells))), axis=2)

    for ic in range(0,5):
      if 'i_comp-%03d' % ic in f[g].keys():
        i = f[g]['i_comp-%03d' % ic][()][0]
        fnew[g].create_dataset('i_comp-%03d' % ic, data=i)
        comp = f[g]['data'][..., i-1]
        if ic < 4:
          data_new[..., i-1] = np.concatenate((comp, np.zeros((nz, ny, ncells))), axis=2)
        else:
          data_new[..., i-1] = interpolate(nx, ny, nz, x, star_xc, prog[6], \
                                       sim_value=comp, n0=n0)

    # Sound speed
    if 'i_csnd' in f[g].keys():
      i = f[g]['i_csnd'][()][0]
      fnew[g].create_dataset('i_csnd', data=i)
      csnd = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((csnd, np.zeros((nz, ny, ncells))), axis=2)

    # delp
    if 'i_delp' in f[g].keys():
      i = f[g]['i_delp'][()][0]
      fnew[g].create_dataset('i_delp', data=i)
      delp = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((delp, np.zeros((nz,ny, ncells))), axis=2)

    # Moments
    if 'i_smomx' in f[g].keys():
      i = f[g]['i_smomx'][()][0]
      fnew[g].create_dataset('i_smomx', data=i)
      smomx = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((smomx, np.zeros((nz, ny, ncells))), axis=2)
    if 'i_smomy' in f[g].keys():
      i = f[g]['i_smomy'][()][0]
      fnew[g].create_dataset('i_smomy', data=i)
      smomy = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((smomy, np.zeros((nz, ny, ncells))), axis=2)
    if 'i_smomz' in f[g].keys():
      i = f[g]['i_smomz'][()][0]
      fnew[g].create_dataset('i_smomz', data=i)
      smomz = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((smomz, np.zeros((nz, ny, ncells))), axis=2)

    # heat
    if 'i_heat' in f[g].keys():
      i = f[g]['i_heat'][()][0]
      fnew[g].create_dataset('i_heat', data=i)
      heat = f[g]['data'][..., i-1]
      data_new[..., i-1] = np.concatenate((heat, np.zeros((nz, ny, ncells))), axis=2)
    
    fnew[g].create_dataset('data', data=data_new)
    
